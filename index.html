

<!DOCTYPE html>
<html class="writer-html5" lang="cn" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>CppCoro - 一个 C++ 协程库 &mdash; cppcoro_chs 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> cppcoro_chs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">CppCoro - 一个 C++ 协程库</a><ul>
<li><a class="reference internal" href="#id2">协程类型</a><ul>
<li><a class="reference internal" href="#task-t">task&lt;T&gt;</a></li>
<li><a class="reference internal" href="#shared-task-t">shared_task&lt;T&gt;</a></li>
<li><a class="reference internal" href="#gengrator-t">gengrator&lt;T&gt;</a></li>
<li><a class="reference internal" href="#recursive-generator-t">recursive_generator&lt;T&gt;</a></li>
<li><a class="reference internal" href="#async-generator-t">async_generator&lt;T&gt;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">异步类型</a><ul>
<li><a class="reference internal" href="#single-consumer-event">single_consumer_event</a></li>
<li><a class="reference internal" href="#single-consumer-async-auto-reset-event">single_consumer_async_auto_reset_event</a></li>
<li><a class="reference internal" href="#async-mutex">async_mutex</a></li>
<li><a class="reference internal" href="#async-manual-reset-event">async_manual_reset_event</a></li>
<li><a class="reference internal" href="#async-auto-reset-event">async_auto_reset_event</a></li>
<li><a class="reference internal" href="#async-latch">async_latch</a></li>
<li><a class="reference internal" href="#sequence-barrier">sequence_barrier</a></li>
<li><a class="reference internal" href="#single-producer-sequencer">single_producer_sequencer</a></li>
<li><a class="reference internal" href="#multi-producer-sequencer">multi_producer_sequencer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">撤销操作</a><ul>
<li><a class="reference internal" href="#cancellation-token">cancellation_token</a></li>
<li><a class="reference internal" href="#cancellation-source">cancellation_source</a></li>
<li><a class="reference internal" href="#cancellation-registration">cancellation_registration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-o">I/O 调度</a><ul>
<li><a class="reference internal" href="#static-thread-pool">static_thread_pool</a></li>
<li><a class="reference internal" href="#io-service-and-io-work-scope">io_service and io_work_scope</a></li>
<li><a class="reference internal" href="#file-readable-file-writable-file">file, readable_file, writable_file</a></li>
<li><a class="reference internal" href="#read-only-file-write-only-file-read-write-file">read_only_file, write_only_file, read_write_file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">网络</a><ul>
<li><a class="reference internal" href="#socket">socket</a></li>
<li><a class="reference internal" href="#ip-address-ipv4-address-ipv6-address">ip_address, ipv4_address, ipv6_address</a></li>
<li><a class="reference internal" href="#ip-endpoint-ipv4-endpoint-ipv6-endpoint">ip_endpoint, ipv4_endpoint, ipv6_endpoint</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">函数</a><ul>
<li><a class="reference internal" href="#sync-wait">sync_wait()</a></li>
<li><a class="reference internal" href="#when-all">when_all()</a></li>
<li><a class="reference internal" href="#when-all-ready">when_all_ready()</a></li>
<li><a class="reference internal" href="#fmap">fmap()</a></li>
<li><a class="reference internal" href="#schedule-on">schedule_on()</a></li>
<li><a class="reference internal" href="#resume-on">resume_on()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">元函数</a><ul>
<li><a class="reference internal" href="#awaitable-traits-t">awaitable_traits&lt;T&gt;</a></li>
<li><a class="reference internal" href="#is-awaitable-t">is_awaitable&lt;T&gt;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">概念</a><ul>
<li><a class="reference internal" href="#awaitable-t">Awaitable&lt;T&gt;</a></li>
<li><a class="reference internal" href="#awaiter-t">Awaiter&lt;T&gt;</a></li>
<li><a class="reference internal" href="#scheduler">Scheduler</a></li>
<li><a class="reference internal" href="#delayedscheduler">DelayedScheduler</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">构建</a><ul>
<li><a class="reference internal" href="#windows">在 Windows 上构建</a><ul>
<li><a class="reference internal" href="#id13">Windows 环境需求</a></li>
<li><a class="reference internal" href="#clone">Clone 仓库</a></li>
<li><a class="reference internal" href="#id14">从命令行构构建</a></li>
<li><a class="reference internal" href="#visual-studio">使用 Visual Studio 项目文件构建</a></li>
</ul>
</li>
<li><a class="reference internal" href="#linux">在 Linux 上构建</a><ul>
<li><a class="reference internal" href="#id15">Linux 环境需求</a></li>
<li><a class="reference internal" href="#cppcoro">构建 cppcoro</a></li>
<li><a class="reference internal" href="#clang">自定义 Clang 位置</a></li>
<li><a class="reference internal" href="#id16">使用 Clang 的快照构建</a></li>
<li><a class="reference internal" href="#id17">构建你的 Clang</a></li>
<li><a class="reference internal" href="#libc">构建 libc++</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id18">支持</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">cppcoro_chs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>CppCoro - 一个 C++ 协程库</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cppcoro-c">
<h1><a class="toc-backref" href="#id19">CppCoro - 一个 C++ 协程库</a><a class="headerlink" href="#cppcoro-c" title="Permalink to this headline">¶</a></h1>
<p><strong>cppcoro</strong> 提供了大量通用原语以便于使用 TS <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf">N4680</a> 提案描述的协程</p>
<p>这包括：</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#cppcoro-c" id="id19">CppCoro - 一个 C++ 协程库</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id20">协程类型</a></p>
<ul>
<li><p><a class="reference internal" href="#task-t" id="id21">task&lt;T&gt;</a></p></li>
<li><p><a class="reference internal" href="#shared-task-t" id="id22">shared_task&lt;T&gt;</a></p></li>
<li><p><a class="reference internal" href="#gengrator-t" id="id23">gengrator&lt;T&gt;</a></p></li>
<li><p><a class="reference internal" href="#recursive-generator-t" id="id24">recursive_generator&lt;T&gt;</a></p></li>
<li><p><a class="reference internal" href="#async-generator-t" id="id25">async_generator&lt;T&gt;</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id3" id="id26">异步类型</a></p>
<ul>
<li><p><a class="reference internal" href="#single-consumer-event" id="id27">single_consumer_event</a></p></li>
<li><p><a class="reference internal" href="#single-consumer-async-auto-reset-event" id="id28">single_consumer_async_auto_reset_event</a></p></li>
<li><p><a class="reference internal" href="#async-mutex" id="id29">async_mutex</a></p></li>
<li><p><a class="reference internal" href="#async-manual-reset-event" id="id30">async_manual_reset_event</a></p></li>
<li><p><a class="reference internal" href="#async-auto-reset-event" id="id31">async_auto_reset_event</a></p></li>
<li><p><a class="reference internal" href="#async-latch" id="id32">async_latch</a></p></li>
<li><p><a class="reference internal" href="#sequence-barrier" id="id33">sequence_barrier</a></p></li>
<li><p><a class="reference internal" href="#single-producer-sequencer" id="id34">single_producer_sequencer</a></p></li>
<li><p><a class="reference internal" href="#multi-producer-sequencer" id="id35">multi_producer_sequencer</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id4" id="id36">撤销操作</a></p>
<ul>
<li><p><a class="reference internal" href="#cancellation-token" id="id37">cancellation_token</a></p></li>
<li><p><a class="reference internal" href="#cancellation-source" id="id38">cancellation_source</a></p></li>
<li><p><a class="reference internal" href="#cancellation-registration" id="id39">cancellation_registration</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#i-o" id="id40">I/O 调度</a></p>
<ul>
<li><p><a class="reference internal" href="#static-thread-pool" id="id41">static_thread_pool</a></p></li>
<li><p><a class="reference internal" href="#io-service-and-io-work-scope" id="id42">io_service and io_work_scope</a></p></li>
<li><p><a class="reference internal" href="#file-readable-file-writable-file" id="id43">file, readable_file, writable_file</a></p></li>
<li><p><a class="reference internal" href="#read-only-file-write-only-file-read-write-file" id="id44">read_only_file, write_only_file, read_write_file</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id45">网络</a></p>
<ul>
<li><p><a class="reference internal" href="#socket" id="id46">socket</a></p></li>
<li><p><a class="reference internal" href="#ip-address-ipv4-address-ipv6-address" id="id47">ip_address, ipv4_address, ipv6_address</a></p></li>
<li><p><a class="reference internal" href="#ip-endpoint-ipv4-endpoint-ipv6-endpoint" id="id48">ip_endpoint, ipv4_endpoint, ipv6_endpoint</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id6" id="id49">函数</a></p>
<ul>
<li><p><a class="reference internal" href="#sync-wait" id="id50">sync_wait()</a></p></li>
<li><p><a class="reference internal" href="#when-all" id="id51">when_all()</a></p></li>
<li><p><a class="reference internal" href="#when-all-ready" id="id52">when_all_ready()</a></p></li>
<li><p><a class="reference internal" href="#fmap" id="id53">fmap()</a></p></li>
<li><p><a class="reference internal" href="#schedule-on" id="id54">schedule_on()</a></p></li>
<li><p><a class="reference internal" href="#resume-on" id="id55">resume_on()</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id9" id="id56">元函数</a></p>
<ul>
<li><p><a class="reference internal" href="#awaitable-traits-t" id="id57">awaitable_traits&lt;T&gt;</a></p></li>
<li><p><a class="reference internal" href="#is-awaitable-t" id="id58">is_awaitable&lt;T&gt;</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id10" id="id59">概念</a></p>
<ul>
<li><p><a class="reference internal" href="#awaitable-t" id="id60">Awaitable&lt;T&gt;</a></p></li>
<li><p><a class="reference internal" href="#awaiter-t" id="id61">Awaiter&lt;T&gt;</a></p></li>
<li><p><a class="reference internal" href="#scheduler" id="id62">Scheduler</a></p></li>
<li><p><a class="reference internal" href="#delayedscheduler" id="id63">DelayedScheduler</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id11" id="id64">构建</a></p>
<ul>
<li><p><a class="reference internal" href="#windows" id="id65">在 Windows 上构建</a></p>
<ul>
<li><p><a class="reference internal" href="#id13" id="id66">Windows 环境需求</a></p></li>
<li><p><a class="reference internal" href="#clone" id="id67">Clone 仓库</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id68">从命令行构构建</a></p></li>
<li><p><a class="reference internal" href="#visual-studio" id="id69">使用 Visual Studio 项目文件构建</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#linux" id="id70">在 Linux 上构建</a></p>
<ul>
<li><p><a class="reference internal" href="#id15" id="id71">Linux 环境需求</a></p></li>
<li><p><a class="reference internal" href="#cppcoro" id="id72">构建 cppcoro</a></p></li>
<li><p><a class="reference internal" href="#clang" id="id73">自定义 Clang 位置</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id74">使用 Clang 的快照构建</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id75">构建你的 Clang</a></p></li>
<li><p><a class="reference internal" href="#libc" id="id76">构建 libc++</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#id18" id="id77">支持</a></p></li>
</ul>
</li>
</ul>
</div>
<p>这个库是一个实验性的库，它在 C++ 协程的基础上探索高性能、可伸缩的异步编程抽象。</p>
<p>这个库是开源的，并希望其他人能够发现它的优点并提供反馈以及改进它的方法</p>
<p>它要求编译器支持协程：</p>
<ul class="simple">
<li><p>Windows + Visual Studio 2017 <a class="reference external" href="https://ci.appveyor.com/project/lewissbaker/cppcoro/branch/master"><img alt="Windows 构建状态" src="https://ci.appveyor.com/api/projects/status/github/lewissbaker/cppcoro?branch=master&amp;svg=true&amp;passingText=master%20-%20OK&amp;failingText=master%20-%20Failing&amp;pendingText=master%20-%20Pending" /></a></p></li>
</ul>
<ul class="simple">
<li><p>Linux + Clang 5.0/6.0 + libc++ <a class="reference external" href="https://travis-ci.org/lewissbaker/cppcoro"><img alt="Linux 构建状态" src="https://travis-ci.org/lewissbaker/cppcoro.svg?branch=master" /></a></p></li>
</ul>
<p>Linux 除了 <code class="docutils literal notranslate"><span class="pre">io_context</span></code> 和 文件 I/O 相关的类没有实现外，其余功能都是可用的。（详情请参阅  <a class="reference external" href="https://github.com/lewissbaker/cppcoro/issues/15">#15</a> ）</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id20">协程类型</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="task-t">
<h3><a class="toc-backref" href="#id21">task&lt;T&gt;</a><a class="headerlink" href="#task-t" title="Permalink to this headline">¶</a></h3>
<p>一个 task 代表一个异步的延迟计算，因为它直到被等待时才会开始运行（而不是创建时）。</p>
<p>比如：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cppcoro/read_only_file.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/task.hpp&gt;</span><span class="cp"></span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count_lines</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">auto</span> <span class="n">file</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">read_only_file</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">lineCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">bytesRead</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span>
<span class="p">{</span>
   <span class="n">bytesRead</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
   <span class="n">lineCount</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">bytesRead</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
   <span class="n">offset</span> <span class="o">+=</span> <span class="n">bytesRead</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bytesRead</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">co_return</span> <span class="n">lineCount</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">usage_example</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 调用函数创建一个新的 task ，但是 task 这时候并没有开始运行</span>
<span class="c1">// executing the coroutine yet.</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">countTask</span> <span class="o">=</span> <span class="n">count_lines</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// 协程仅在被 co_await 后才开始运行</span>
<span class="kt">int</span> <span class="n">lineCount</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">countTask</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;line count = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">lineCount</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>API 概览：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/task.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">task</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">unspecified</span><span class="o">&gt;</span><span class="p">;</span>
   <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

   <span class="n">task</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">task</span><span class="p">(</span><span class="n">task</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>

   <span class="c1">// task 是一个只能被移动的类型</span>
   <span class="n">task</span><span class="p">(</span><span class="k">const</span> <span class="n">task</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">task</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="c1">// 查询 task 是否已经准备好了</span>
   <span class="kt">bool</span> <span class="nf">is_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 等待 task 运行完毕</span>
   <span class="c1">// 如果 task 执行时出现了未捕获的异常，那么将其重新抛出</span>
   <span class="c1">//</span>
   <span class="c1">// 如果任务还没有准备好，那么挂起直到 task 完成，如果 task is_ready() ，那么直接返回异步计算的结果</span>
   <span class="n">Awaiter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="k">operator</span> <span class="n">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">Awaiter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="k">operator</span> <span class="n">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 返回一个 awaitable 对象，以便于 co_await 暂停协程直至 task 完成</span>
   <span class="c1">//</span>
   <span class="c1">// 与表达式 ``co_await t`` 不同的是，``co_await t.when_ready()`` 中的 when_ready() 是同步的，而且不会返回计算结果，或者是重新抛出异常</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">when_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// Creates a task that yields the result of co_await&#39;ing the specified awaitable.</span>
<span class="c1">//</span>
<span class="c1">// This can be used as a form of type-erasure of the concrete awaitable, allowing</span>
<span class="c1">// different awaitables that return the same await-result type to be stored in</span>
<span class="c1">// the same task&lt;RESULT&gt; type.</span>
<span class="k">template</span><span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="p">,</span>
   <span class="k">typename</span> <span class="n">RESULT</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="o">&gt;</span>
<span class="n">task</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;</span> <span class="n">make_task</span><span class="p">(</span><span class="n">AWAITABLE</span> <span class="n">awaitable</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>你可以通过调用返回值为 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 的函数来产生 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 对象。</p>
<p>协程必须包含 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 或 <code class="docutils literal notranslate"><span class="pre">co_return</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 也许不使用 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 关键字</p>
</div>
<p>当一个返回值为 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 的协程被调用时，如果需要，将会获得一个协程帧。协程的参数在协程帧内完成捕获。然后协程将会在函数起始处被暂停，并返回一个用于表示异步计算结果的 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 值被 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 后，协程将开始执行计算。然后等待的协成将被挂起，然后执行与 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 相关联的协程。挂起的协程将在其关联的 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 被 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 后唤醒。此线程要么 <code class="docutils literal notranslate"><span class="pre">co_return</span></code>，要么跑出异常并被终止。</p>
<p>如果 task 已经完成，那么再次等待它将获得已经计算的结果，而不会重新计算。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">task</span></code> 对象在被 co_await 之前就被销毁了，那么协程永远不会被执行。析构函数只会简单地释放协程帧内由于捕获参数而分配的内存。</p>
</div>
<div class="section" id="shared-task-t">
<h3><a class="toc-backref" href="#id22">shared_task&lt;T&gt;</a><a class="headerlink" href="#shared-task-t" title="Permalink to this headline">¶</a></h3>
<p>协程类 <code class="docutils literal notranslate"><span class="pre">shared_task&lt;T&gt;</span></code> 以异步、惰性的方式产生单个值。</p>
<p>所谓 <strong>惰性</strong>，就是指仅当有协程 await 它的时候才开始执行计算。</p>
<p>它是 <strong>共享</strong> 的：task 允许被拷贝； task 的返回值可以被多次引用； task 可以被多个协程 await。</p>
<p>它在第一次被 co_await 时执行，其余 await 的协程要么挂起进入等待队列，要么直接拿到已经计算的结果。</p>
<p>如果协程由于 await task 被挂起，那么其将会在 task 完成计算后被唤醒。task 要么 <code class="docutils literal notranslate"><span class="pre">co_return</span></code> 一个值，要么抛出一个未捕获的异常。</p>
<p>API 摘要:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">shared_task</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">unspecified</span><span class="o">&gt;</span><span class="p">;</span>
   <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

   <span class="n">shared_task</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">shared_task</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_task</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">shared_task</span><span class="p">(</span><span class="n">shared_task</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">shared_task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_task</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">shared_task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">shared_task</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">shared_task</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 查询 task 是否已经完成，而且计算结果已经可用</span>
   <span class="kt">bool</span> <span class="nf">is_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 返回一个 operation，其将会在被 await 时挂起当前协程，直到 task 完成而且计算结果可用。</span>
   <span class="c1">//</span>
   <span class="c1">// 表达式 ``co_await someTask`` 的结果是一个指向 task 计算结果的左值引用（除非 T 的类</span>
   <span class="c1">// 型是 void，此时这个表达式的结果类型为 void）</span>
   <span class="c1">// 未捕获异常将被 co_await 表达式重新抛出</span>
   <span class="n">Awaiter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span> <span class="k">operator</span> <span class="n">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="c1">// 返回一个 operation，其将会在被 await 时挂起当前协程，直到 task 完成而且计算结果可用</span>
   <span class="c1">// 此 co_await 表达式不会返回任何值。</span>
   <span class="c1">// 此表达式可用于与 task 进行同步而不用担心抛出异常。</span>
   <span class="n">Awaiter</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">when_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">shared_task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">shared_task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">shared_task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">shared_task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// 包装一个可 await 的值，以允许多个协程同时等待它</span>
<span class="k">template</span><span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="p">,</span>
   <span class="k">typename</span> <span class="n">RESULT</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="o">&gt;</span>
<span class="n">shared_task</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;</span> <span class="n">make_shared_task</span><span class="p">(</span><span class="n">AWAITABLE</span> <span class="n">awaitable</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>const 限定的函数可以安全地在多个线程中调用，是线程安全的，但是非 const 限定的函数则不然。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>与 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 相比而言：</p>
<ul class="simple">
<li><p>都是延迟计算：计算只在被 co_await 后才开始。</p></li>
<li><p>task&lt;T&gt; 的结果不允许被拷贝，是仅移动的。而 shared_task 可以被拷贝和移动</p></li>
<li><p>由于可能被共享，shared_task 的结果总是左值，这可能导致局部变量无法进行'移动构造'，而且由于需要维护引用计数，其运行时成本略高。</p></li>
</ul>
</div>
</div>
<div class="section" id="gengrator-t">
<h3><a class="toc-backref" href="#id23">gengrator&lt;T&gt;</a><a class="headerlink" href="#gengrator-t" title="Permalink to this headline">¶</a></h3>
<p>一个 <abbr title="Gengrator">生成器</abbr> 用于产生一系列类型为 T 的值。值的产生是惰性和异步的。</p>
<p>协程可以使用 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 来产生一个类型为 T 的值。但是协程内无法使用 co_await 关键字。值的产生必须是同步的。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cppcoro::generator&lt;const std::uint64_t&gt; fibonacci()
{
std::uint64_t a = 0, b = 1;
while (true)
{
   co_yield b;
   auto tmp = a;
   a = b;
   b += tmp;
}
}

void usage()
{
for (auto i : fibonacci())
{
   if (i &gt; 1&#39;000&#39;000) break;
   std::cout &lt;&lt; i &lt;&lt; std::endl;
}
}
</pre></div>
</div>
<p>当一个返回值为``generator&lt;T&gt;`` 的协程函数被调用后，其会被立即挂起。直到 <code class="docutils literal notranslate"><span class="pre">generator&lt;T&gt;::begin()</span></code> 函数被调用。在 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 达到终点或者协程完成后不在产生值。</p>
<p>如果返回的迭代器与 <code class="docutils literal notranslate"><span class="pre">end()</span></code> 不相等，那么对迭代器进行解引用将会返回'传递给 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> '的值。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">operator()++</span></code> 将会恢复协程的运行，直至协程结束或 co_yield 不再产生新的值。</p>
<p>API 摘要:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
   <span class="k">class</span> <span class="nc">generator</span>
   <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>

      <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">unspecified</span><span class="o">&gt;</span><span class="p">;</span>

      <span class="k">class</span> <span class="nc">iterator</span>
      <span class="p">{</span>
      <span class="k">public</span><span class="o">:</span>
            <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">input_iterator_tag</span><span class="p">;</span>
            <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
            <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">value_type</span><span class="o">&amp;</span><span class="p">;</span>
            <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">value_type</span><span class="o">*</span><span class="p">;</span>
            <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>

            <span class="n">iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
            <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

            <span class="c1">// 如果异常在 co_yield 之前参数，异常将被重新抛出。</span>
            <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>

            <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
            <span class="n">pointer</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="p">};</span>

      <span class="c1">// 构造一个空的序列</span>
      <span class="n">generator</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

      <span class="n">generator</span><span class="p">(</span><span class="n">generator</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="n">generator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">generator</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

      <span class="n">generator</span><span class="p">(</span><span class="k">const</span> <span class="n">generator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
      <span class="n">generator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">generator</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

      <span class="o">~</span><span class="n">generator</span><span class="p">();</span>

      <span class="c1">// 开始执行协成，直至 co_yield 不再产生新的值或协程结束或未捕获异常被抛出</span>
      <span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>

      <span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

      <span class="c1">// 交换两个生成器</span>
      <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">generator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="p">};</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
   <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 以 source 为基础，对其每个元素调用一次 func 来产生一个新的序列。</span>
   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FUNC</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
   <span class="n">generator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&gt;&gt;</span> <span class="n">fmap</span><span class="p">(</span><span class="n">FUNC</span> <span class="n">func</span><span class="p">,</span> <span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">source</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recursive-generator-t">
<h3><a class="toc-backref" href="#id24">recursive_generator&lt;T&gt;</a><a class="headerlink" href="#recursive-generator-t" title="Permalink to this headline">¶</a></h3>
<p>相比生成器而言， <abbr title="Recursive Generator">递归生成器</abbr> 能够生成嵌套在外部元素的序列。</p>
<p><code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 除了可以生成类型 T 的元素外，还能生成一个元素为 T 的递归生成器。</p>
<p>当你 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 一个递归生成器时，其将被作为当前元素的子元素。当前线程将被挂起，直至递归生成器的所有元素被生成。然后被唤醒，等待请求下一个元素。</p>
<p>相比普通生成器而言，在迭代嵌套数据结构时，递归生成器能够通过 <code class="docutils literal notranslate"><span class="pre">iterator::operator++()</span></code> 直接唤醒边缘协程以产生下一个元素，而不必未每个元素都暂停/唤醒一个 O(depth) 的协程。缺点是有额外开销。</p>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 列出当前目录的内容</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">dir_entry</span><span class="o">&gt;</span> <span class="n">list_directory</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">path</span><span class="p">);</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">recursive_generator</span><span class="o">&lt;</span><span class="n">dir_entry</span><span class="o">&gt;</span> <span class="n">list_directory_recursive</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">entry</span> <span class="p">:</span> <span class="n">list_directory</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
<span class="p">{</span>
   <span class="n">co_yield</span> <span class="n">entry</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">())</span>
   <span class="p">{</span>
      <span class="n">co_yield</span> <span class="n">list_directory_recursive</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">());</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>对 <code class="docutils literal notranslate"><span class="pre">recursive_generator&lt;T&gt;</span></code> 应用 <code class="docutils literal notranslate"><span class="pre">fmap()</span></code> 操作时，将产生 <code class="docutils literal notranslate"><span class="pre">generator&lt;U&gt;</span></code> 类型，而不是 <code class="docutils literal notranslate"><span class="pre">recursive_generator&lt;U&gt;</span></code> 类型。这是因为通常在递归上下文中不使用 <code class="docutils literal notranslate"><span class="pre">fmap</span></code> 操作，我们避免递归生成器的格外开销。</p>
</div>
</div>
<div class="section" id="async-generator-t">
<h3><a class="toc-backref" href="#id25">async_generator&lt;T&gt;</a><a class="headerlink" href="#async-generator-t" title="Permalink to this headline">¶</a></h3>
<p><abbr title="Async Generator">异步生成器</abbr> 用于产生类型为 T 的序列。值是惰性、异步产生的。</p>
<p>此协程体内既可以使用 <code class="docutils literal notranslate"><span class="pre">co_wait</span></code> 也可以使用 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code></p>
<p>可以通过基于 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">co_await</span></code> 来处理数据序列。</p>
<p>比如：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cppcoro</span><span class="o">::</span><span class="n">async_generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ticker</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">threadpool</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">co_await</span> <span class="n">tp</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
   <span class="n">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">consumer</span><span class="p">(</span><span class="n">threadpool</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">auto</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">ticker</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="k">for</span> <span class="nf">co_await</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">sequence</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Tick &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>API 摘要:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/async_generator.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">async_generator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="k">class</span> <span class="nc">iterator</span>
   <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="k">using</span> <span class="n">iterator_tag</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_iterator_tag</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">value_type</span><span class="o">&amp;</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">value_type</span><span class="o">*</span><span class="p">;</span>

      <span class="n">iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

      <span class="c1">// 如果协程被挂起，则唤醒它</span>
      <span class="c1">// 返回一个 operation ，其必须被 await 至自增操作结束</span>
      <span class="c1">// 最后返回的迭代器与 end() 相等</span>
      <span class="c1">// 若有未捕获异常，则将其抛出</span>
      <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&amp;&gt;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

      <span class="c1">// 对迭代器解引用</span>
      <span class="n">pointer</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

      <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="c1">// 构造一个空的序列</span>
   <span class="n">async_generator</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">async_generator</span><span class="p">(</span><span class="k">const</span> <span class="n">async_generator</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_generator</span><span class="p">(</span><span class="n">async_generator</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="o">~</span><span class="n">async_generator</span><span class="p">();</span>

   <span class="n">async_generator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">async_generator</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_generator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">async_generator</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">async_generator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 开始执行协程并返回起一个 operation，其必须被 await 至第一个元素可用</span>
   <span class="c1">// co_wait 获得的是一个迭代器对象，并且可用其来推动协程的执行</span>
   <span class="c1">// 在协程执行结束后，调用此函数是非法的</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">async_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">async_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// 以 source 为基础，对其每个元素调用一次 func 来产生一个新的序列。</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FUNC</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">async_generator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&gt;&gt;</span> <span class="n">fmap</span><span class="p">(</span><span class="n">FUNC</span> <span class="n">func</span><span class="p">,</span> <span class="n">async_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">source</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>异步迭代器的提前终止：</p>
<p>当异步生成器被析构时，它将请求取消协程。如果协程已经运行结束，或者在 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 表达式中挂起，那么协程立即被销毁。否则协程将继续执行，直到它运行结束或到达下一个 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 表达式。</p>
<p>在协程被销毁时，其作用于内的所有变量也将被销毁，以确保完全清理资源。</p>
<p>在协程使用 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 等待下一个元素时，调用者必须确保此时异步生成器不被销毁。</p>
</div>
</div>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id26">异步类型</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="single-consumer-event">
<h3><a class="toc-backref" href="#id27">single_consumer_event</a><a class="headerlink" href="#single-consumer-event" title="Permalink to this headline">¶</a></h3>
<p>这是一个简单的手动重置事件类型。其在同一时间内只能被一个协程等待。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/single_consumer_event.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">single_consumer_event</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">single_consumer_event</span><span class="p">(</span><span class="kt">bool</span> <span class="n">initiallySet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">set</span><span class="p">();</span>
   <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">Awaiter</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cppcoro/single_consumer_event.hpp&gt;</span><span class="cp"></span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">single_consumer_event</span> <span class="n">event</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">consumer</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 协程将会在此处挂起，直至有线程调用 event.set()</span>
<span class="c1">// 比如下面的 producer() 函数</span>
<span class="n">co_await</span> <span class="n">event</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">producer</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>

<span class="c1">// This will resume the consumer() coroutine inside the call to set()</span>
<span class="c1">// if it is currently suspended.</span>
<span class="n">event</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="single-consumer-async-auto-reset-event">
<h3><a class="toc-backref" href="#id28">single_consumer_async_auto_reset_event</a><a class="headerlink" href="#single-consumer-async-auto-reset-event" title="Permalink to this headline">¶</a></h3>
<p>这个类提供了一个异步同步原语以允许单个协程等待事件至信号发射。信号可以通过调用 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 函数被发射。</p>
<p>一旦等待事件的协程被前面或后面对 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 的调用释放，事件就会自动重置回 'not set' 状态。</p>
<p>相比 <code class="docutils literal notranslate"><span class="pre">async_auto_reset_event</span></code> 而言，本类更有效率，本类在同一时间仅允许一个类进入等待状态。如果你需要多个协程在同一时间等待时间，请使用 <code class="docutils literal notranslate"><span class="pre">async_auto_reset_event</span></code> 。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/single_consumer_async_auto_reset_event.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">single_consumer_async_auto_reset_event</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="n">single_consumer_async_auto_reset_event</span><span class="p">(</span>
      <span class="kt">bool</span> <span class="n">initiallySet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 将事件的状态改为 &#39;set&#39; 。等待此事件的协程将被立即唤醒，之后事件状态自动重置为 &#39;not set&#39;</span>
   <span class="kt">void</span> <span class="nf">set</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// Returns an Awaitable type that can be awaited to wait until</span>
   <span class="c1">// the event becomes &#39;set&#39; via a call to the .set() method. If</span>
   <span class="c1">// the event is already in the &#39;set&#39; state then the coroutine</span>
   <span class="c1">// continues without suspending.</span>
   <span class="c1">// The event is automatically reset back to the &#39;not set&#39; state</span>
   <span class="c1">// before resuming the coroutine.</span>
   <span class="n">Awaiter</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">single_consumer_async_auto_reset_event</span> <span class="n">valueDecreasedEvent</span><span class="p">;</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">wait_until_value_is_below</span><span class="p">(</span><span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// 在此等待至 valueDecreasedEvent 事件的状态变为 set</span>
   <span class="n">co_await</span> <span class="n">valueDecreasedEvent</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">change_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">value</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="c1">// 如果此处 valueDecreasedEvent 状态发生改变，则通知挂起的协程</span>
<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">valueDecreasedEvent</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="async-mutex">
<h3><a class="toc-backref" href="#id29">async_mutex</a><a class="headerlink" href="#async-mutex" title="Permalink to this headline">¶</a></h3>
<p>提供了一个简单的互斥抽象，允许调用者在协程中 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 互斥锁，挂起协程，直到获得互斥锁。</p>
<p>这个实现是无锁的，因为等待互斥锁的协程不会阻塞线程，而是挂起协程，然后前一个锁持有者通过调用 unlock() 来唤醒它。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/async_mutex.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">async_mutex_lock</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">async_mutex_lock_operation</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">async_mutex_scoped_lock_operation</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">async_mutex</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">async_mutex</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="o">~</span><span class="n">async_mutex</span><span class="p">();</span>

   <span class="n">async_mutex</span><span class="p">(</span><span class="k">const</span> <span class="n">async_mutex</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_mutex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">async_mutex</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">try_lock</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">async_mutex_lock_operation</span> <span class="nf">lock_async</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">async_mutex_scoped_lock_operation</span> <span class="nf">scoped_lock_async</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">unlock</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">async_mutex_lock_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">async_mutex_scoped_lock_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">async_mutex_lock</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">async_mutex_lock</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="c1">// 获得锁的所有权</span>
   <span class="n">async_mutex_lock</span><span class="p">(</span><span class="n">async_mutex</span><span class="o">&amp;</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock_t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 移交锁的所有权</span>
   <span class="n">async_mutex_lock</span><span class="p">(</span><span class="n">async_mutex_lock</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">async_mutex_lock</span><span class="p">(</span><span class="k">const</span> <span class="n">async_mutex_lock</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_mutex_lock</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">async_mutex_lock</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="c1">// 通过调用 unlock() 来解锁</span>
   <span class="o">~</span><span class="n">async_mutex_lock</span><span class="p">();</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cppcoro/async_mutex.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/task.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">async_mutex</span> <span class="n">mutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">add_item</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">async_mutex_lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">mutex</span><span class="p">.</span><span class="n">scoped_lock_async</span><span class="p">();</span>
<span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="async-manual-reset-event">
<h3><a class="toc-backref" href="#id30">async_manual_reset_event</a><a class="headerlink" href="#async-manual-reset-event" title="Permalink to this headline">¶</a></h3>
<p>一个手动重置的事件，是一个 协程/线程 同步原语。其允许多个协程进入等待状态，直至事件通过调用 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 函数改变状态。</p>
<p>此事件永源处于 'set' 或 'not set' 状态之一。</p>
<p>如果协程在等待前事件已经是 'set' 状态，那么协程不会进入等待状态。否则，协程将会被挂起，直至事件状态通过 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 函数被更换为 'set' 。</p>
<p>当事件状态改变为 'set' 时，所有由于等待事件被挂起的线程都会被某个线程唤醒。</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>请注意，当事件被销毁时，必须确保没有协程由于等待事件被挂起，因为它们将永远不会被唤醒。</p>
</div>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">async_manual_reset_event_operation</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">async_manual_reset_event</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="kt">bool</span> <span class="n">initiallySet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="o">~</span><span class="n">async_manual_reset_event</span><span class="p">();</span>

   <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="c1">// Wait until the event becomes set.</span>
   <span class="n">async_manual_reset_event_operation</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">set</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">async_manual_reset_event_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">async_manual_reset_event_operation</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cppcoro</span><span class="o">::</span><span class="n">async_manual_reset_event</span> <span class="n">event</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">get_some_string_value</span><span class="p">();</span>

<span class="c1">// 通过设置事件来发布一个值</span>
<span class="n">event</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 能够被调用多次以产生多个 task</span>
<span class="c1">// 所有的 consumer task 将会等待至值被发布</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">consumer</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 等待至值被事件发布</span>
<span class="n">co_await</span> <span class="n">event</span><span class="p">;</span>

<span class="n">consume_value</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="async-auto-reset-event">
<h3><a class="toc-backref" href="#id31">async_auto_reset_event</a><a class="headerlink" href="#async-auto-reset-event" title="Permalink to this headline">¶</a></h3>
<p>一个手动重置的事件，是一个 协程/线程 同步原语。其允许多个协程进入等待状态，直至事件通过调用 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 函数改变状态。</p>
<p>一旦由于等待事件被挂起的线程被唤醒，则事件自动进入 'not set' 状态。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/async_auto_reset_event.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">async_auto_reset_event_operation</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">async_auto_reset_event</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="n">async_auto_reset_event</span><span class="p">(</span><span class="kt">bool</span> <span class="n">initiallySet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="o">~</span><span class="n">async_auto_reset_event</span><span class="p">();</span>

   <span class="n">async_auto_reset_event</span><span class="p">(</span><span class="k">const</span> <span class="n">async_auto_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_auto_reset_event</span><span class="p">(</span><span class="n">async_auto_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_auto_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">async_auto_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">async_auto_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">async_auto_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="c1">// 等待至事件进入 &#39;set&#39; 状态</span>
   <span class="c1">//</span>
   <span class="c1">// 如果事件已经是 &#39;set&#39; 状态了，则事件自动进入 &#39;not set&#39; 状态，而且 await 的协程</span>
   <span class="c1">// 会继续执行而不是挂起。</span>
   <span class="c1">// 否则，协程将被挂起至一些线程调用 &#39;set()&#39; 函数</span>
   <span class="c1">//</span>
   <span class="c1">// 注意：挂起的线程可因 &#39;set()&#39; 调用或者其他线程调用 &#39;operator co_await()&#39; 而被唤醒。</span>
   <span class="n">async_auto_reset_event_operation</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 将事件的状态更改为 &#39;set&#39;</span>
   <span class="c1">//</span>
   <span class="c1">// 如果有因等待事件被挂起的协程，则其中之一会被唤醒，然后事件自动进入 &#39;not set&#39; 状态</span>
   <span class="c1">//</span>
   <span class="c1">// 如果事件已经为 &#39;set&#39; 状态，则此函数不进行任何操作。</span>
   <span class="kt">void</span> <span class="nf">set</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 设置事件状态为 &#39;not set&#39;</span>
   <span class="c1">//</span>
   <span class="c1">// 如果事件已经为 &#39;not set&#39; 状态，则此函数不进行任何操作。</span>
   <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">async_auto_reset_event_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">explicit</span> <span class="n">async_auto_reset_event_operation</span><span class="p">(</span><span class="n">async_auto_reset_event</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">async_auto_reset_event_operation</span><span class="p">(</span><span class="k">const</span> <span class="n">async_auto_reset_event_operation</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="async-latch">
<h3><a class="toc-backref" href="#id32">async_latch</a><a class="headerlink" href="#async-latch" title="Permalink to this headline">¶</a></h3>
<p><abbr title="Async Latch">异步锁存器</abbr> 是一个同步原语，用于异步等待一个计数器递减为零。</p>
<p>此锁存器是一次性的。一旦由于计数器变为零导致锁存器进入 ready 状态，其将保持此状态直至销毁。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/async_latch.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">async_latch</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="c1">// 用指定的计数初始化此锁存器</span>
   <span class="n">async_latch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">initialCount</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 查询计数是否已经变为零</span>
   <span class="kt">bool</span> <span class="nf">is_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 将计数减少 n</span>
   <span class="c1">// 当此函数的调用导致计数为零时，所有等待的协程将被唤醒</span>
   <span class="c1">// 计数器减到负值是未定义行为</span>
   <span class="kt">void</span> <span class="nf">count_down</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 等待锁存器状态变为 ready</span>
   <span class="c1">// 如果计数没有变为零，则所有等待的协程将被挂起，直至由于调用 count_down() 导致计数变为零。</span>
   <span class="c1">// 如果计数已经变为零，则不会被挂起</span>
   <span class="n">Awaiter</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sequence-barrier">
<h3><a class="toc-backref" href="#id33">sequence_barrier</a><a class="headerlink" href="#sequence-barrier" title="Permalink to this headline">¶</a></h3>
<p><abbr title="Sequence Barrier">顺序墙</abbr> 是一个同步原语，允许一个生产者和多个消费者之间通过一个单调递增的数字序列来协作。</p>
<p>生产者通过发布一组单调递增的数来推进序列，消费者则可以查询生产者最后发布的数，并可以等待至特定的数被发布。</p>
<p>顺序墙可以充当线程安全的生产-消费环形缓存区的游标。</p>
<p>有关更多信息，参见 LMAX Disruptor 模式：<a class="reference external" href="https://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf">https://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf</a></p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SEQUENCE</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
         <span class="k">typename</span> <span class="n">TRAITS</span> <span class="o">=</span> <span class="n">sequence_traits</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">sequence_barrier</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">sequence_barrier</span><span class="p">(</span><span class="n">SEQUENCE</span> <span class="n">initialSequence</span> <span class="o">=</span> <span class="n">TRAITS</span><span class="o">::</span><span class="n">initial_sequence</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="o">~</span><span class="n">sequence_barrier</span><span class="p">();</span>

   <span class="n">SEQUENCE</span> <span class="nf">last_published</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 等待至序列号 targetSequence 被发布</span>
   <span class="c1">//</span>
   <span class="c1">// 如果操作没有同步地完成，则等待的协程将被特定的 scheduler 唤醒。否则协程将直接顺序执行而无需等待</span>
   <span class="c1">//</span>
   <span class="c1">// co_await 表达式将在 last_published() 后被唤醒，最后发布的数就是其 targetSequence</span>
   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;</span> <span class="n">wait_until_published</span><span class="p">(</span><span class="n">SEQUENCE</span> <span class="n">targetSequence</span><span class="p">,</span>
                                             <span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">publish</span><span class="p">(</span><span class="n">SEQUENCE</span> <span class="n">sequence</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="single-producer-sequencer">
<h3><a class="toc-backref" href="#id34">single_producer_sequencer</a><a class="headerlink" href="#single-producer-sequencer" title="Permalink to this headline">¶</a></h3>
<p><abbr title="Single Producer Sequencer">单消费者序列起</abbr> 是一个同步原语，可以协调单个生产者和多个消费者对环状缓冲区的访问。</p>
<p>生产者首先向环状缓冲区请求一个或多个槽，然后在槽内写入数据，最终发布这些槽的序列号。生产的数据和未消费的数据之和应小于 bufferSize</p>
<p>消费者等待某些元素的发布，处理这些元素，然后通过发布在 <a class="reference internal" href="#sequence-barrier">sequence_barrier</a> 对象中完成消费的序列号来通知生产者完成了对这些元素的处理。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/single_producer_sequencer.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">SEQUENCE</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
   <span class="k">typename</span> <span class="n">TRAITS</span> <span class="o">=</span> <span class="n">sequence_traits</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">single_producer_sequencer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">sequence_range</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="p">,</span> <span class="n">TRAITS</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>

   <span class="n">single_producer_sequencer</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">sequence_barrier</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="p">,</span> <span class="n">TRAITS</span><span class="o">&gt;&amp;</span> <span class="n">consumerBarrier</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufferSize</span><span class="p">,</span>
      <span class="n">SEQUENCE</span> <span class="n">initialSequence</span> <span class="o">=</span> <span class="n">TRAITS</span><span class="o">::</span><span class="n">initial_sequence</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 生产者 API:</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;</span> <span class="n">claim_one</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">sequence_range</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;&gt;</span> <span class="n">claim_up_to</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
      <span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">publish</span><span class="p">(</span><span class="n">SEQUENCE</span> <span class="n">sequence</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 消费者 API:</span>

   <span class="n">SEQUENCE</span> <span class="nf">last_published</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;</span> <span class="n">wait_until_published</span><span class="p">(</span>
      <span class="n">SEQUENCE</span> <span class="n">targetSequence</span><span class="p">,</span>
      <span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>using namespace cppcoro;
using namespace std::chrono;

struct message
{
int id;
steady_clock::time_point timestamp;
float data;
};

constexpr size_t bufferSize = 16384; // 必须为 2 的幂
constexpr size_t indexMask = bufferSize - 1;
message buffer[bufferSize];

task&lt;void&gt; producer(
io_service&amp; ioSvc,
single_producer_sequencer&lt;size_t&gt;&amp; sequencer)
{
auto start = steady_clock::now();
for (int i = 0; i &lt; 1&#39;000&#39;000; ++i)
{
   // 等待缓冲区内一个可用的槽
   size_t seq = co_await sequencer.claim_one(ioSvc);

   // 填充数据
   auto&amp; msg = buffer[seq &amp; indexMask];
   msg.id = i;
   msg.timestamp = steady_clock::now();
   msg.data = 123;

   // 发布数据
   sequencer.publish(seq);
}

// 发布终止序列号
auto seq = co_await sequencer.claim_one(ioSvc);
auto&amp; msg = buffer[seq &amp; indexMask];
msg.id = -1;
sequencer.publish(seq);
}

task&lt;void&gt; consumer(
static_thread_pool&amp; threadPool,
const single_producer_sequencer&lt;size_t&gt;&amp; sequencer,
sequence_barrier&lt;size_t&gt;&amp; consumerBarrier)
{
size_t nextToRead = 0;
while (true)
{
   // 等待只下一个数据可用
   // 也许有多个数据可用
   const size_t available = co_await sequencer.wait_until_published(nextToRead, threadPool);
   do {
      auto&amp; msg = buffer[nextToRead &amp; indexMask];
      if (msg.id == -1)
      {
      consumerBarrier.publish(nextToRead);
      co_return;
      }

      processMessage(msg);
   } while (nextToRead++ != available);

   // 通知生产者我们已经处理到了 &#39;nextToRead - 1&#39;
   consumerBarrier.publish(available);
}
}

task&lt;void&gt; example(io_service&amp; ioSvc, static_thread_pool&amp; threadPool)
{
sequence_barrier&lt;size_t&gt; barrier;
single_producer_sequencer&lt;size_t&gt; sequencer{barrier, bufferSize};

co_await when_all(
   producer(tp, sequencer),
   consumer(tp, sequencer, barrier));
}
</pre></div>
</div>
</div>
<div class="section" id="multi-producer-sequencer">
<h3><a class="toc-backref" href="#id35">multi_producer_sequencer</a><a class="headerlink" href="#multi-producer-sequencer" title="Permalink to this headline">¶</a></h3>
<p><abbr title="Multi Producer Sequencer">多生产序列器</abbr>  是一个同步原语，可以协调多个生产者和消费者之间对环状缓冲区的访问。</p>
<p>对于单个生产者的变体，请参阅 <a class="reference internal" href="#single-producer-sequencer">single_producer_sequencer</a></p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>环状缓冲区的大小必须为 2 的幂。这是因为此算法实现使用了位掩码来计算缓冲区的偏移值，而不是使用摸运算。而且，这允许序列号被 32/64位值包装。</p>
</div>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/multi_producer_sequencer.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SEQUENCE</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
         <span class="k">typename</span> <span class="n">TRAITS</span> <span class="o">=</span> <span class="n">sequence_traits</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">multi_producer_sequencer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">multi_producer_sequencer</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">sequence_barrier</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="p">,</span> <span class="n">TRAITS</span><span class="o">&gt;&amp;</span> <span class="n">consumerBarrier</span><span class="p">,</span>
      <span class="n">SEQUENCE</span> <span class="n">initialSequence</span> <span class="o">=</span> <span class="n">TRAITS</span><span class="o">::</span><span class="n">initial_sequence</span><span class="p">);</span>

   <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 消费者接口</span>
   <span class="c1">//</span>
   <span class="c1">// 每个消费者保持对他们独一的 &#39;lastKnownPublished&#39; 的追踪。并且需要传递 this 到</span>
   <span class="c1">// 此方法，以便于查询最后升级的、可用的序列号</span>
   <span class="c1">// Consumer interface</span>

   <span class="n">SEQUENCE</span> <span class="nf">last_published_after</span><span class="p">(</span><span class="n">SEQUENCE</span> <span class="n">lastKnownPublished</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;</span> <span class="n">wait_until_published</span><span class="p">(</span>
      <span class="n">SEQUENCE</span> <span class="n">targetSequence</span><span class="p">,</span>
      <span class="n">SEQUENCE</span> <span class="n">lastKnownPublished</span><span class="p">,</span>
      <span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 生产者接口</span>

   <span class="c1">// 查询是否有可用的空间（近似值）</span>
   <span class="kt">bool</span> <span class="nf">any_available</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="o">&gt;</span> <span class="n">claim_one</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">sequence_range</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="p">,</span> <span class="n">TRAITS</span><span class="o">&gt;&gt;</span> <span class="n">claim_up_to</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
      <span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 标记这个特定的序列号为已发布</span>
   <span class="kt">void</span> <span class="nf">publish</span><span class="p">(</span><span class="n">SEQUENCE</span> <span class="n">sequence</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 标记范围内的序列号为已发布</span>
   <span class="kt">void</span> <span class="nf">publish</span><span class="p">(</span><span class="k">const</span> <span class="n">sequence_range</span><span class="o">&lt;</span><span class="n">SEQUENCE</span><span class="p">,</span> <span class="n">TRAITS</span><span class="o">&gt;&amp;</span> <span class="n">range</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id36">撤销操作</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cancellation-token">
<h3><a class="toc-backref" href="#id37">cancellation_token</a><a class="headerlink" href="#cancellation-token" title="Permalink to this headline">¶</a></h3>
<p>一个 <abbr title="Cancellation Token">撤销令牌</abbr> 是一个可以被传递给函数的值，以允许调用者其后请求撤销对该函数的调用。</p>
<p>要获得一个可用于撤销操作的 <code class="docutils literal notranslate"><span class="pre">撤销令牌</span></code> ，你首先需要创建一个``cancellation_source`` 对象。方法 <code class="docutils literal notranslate"><span class="pre">cancellation_source::token()</span></code> 可用于创建新的、与 <code class="docutils literal notranslate"><span class="pre">cancellation_source</span></code> 相关联的 <code class="docutils literal notranslate"><span class="pre">撤销令牌</span></code> 。</p>
<p>然后你可以通过 <code class="docutils literal notranslate"><span class="pre">cancellation_source::request_cancellation()</span></code> 向 <code class="docutils literal notranslate"><span class="pre">cancellation_source</span></code> 传递相关联的撤销令牌，以撤销对函数的调用。</p>
<p>函数以以下两种方式来获得是否有撤销请求：</p>
<ol class="arabic simple">
<li><p>定期调用 <code class="docutils literal notranslate"><span class="pre">cancellation_token::is_cancellation_requested()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">cancellation_token::throw_if_cancellation_requested()</span></code></p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">cancellation_registration</span></code> 类注册一个 <em>在出现撤销请求时调用的回调函数</em> 。</p></li>
</ol>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">cancellation_source</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="c1">// 构造一个新的、独立的、可撤销的 cancellation_source</span>
   <span class="n">cancellation_source</span><span class="p">();</span>

   <span class="c1">// 构造一个与 other 撤销状态相同的新引用</span>
   <span class="n">cancellation_source</span><span class="p">(</span><span class="k">const</span> <span class="n">cancellation_source</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">cancellation_source</span><span class="p">(</span><span class="n">cancellation_source</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="o">~</span><span class="n">cancellation_source</span><span class="p">();</span>

   <span class="n">cancellation_source</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">cancellation_source</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">cancellation_source</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">cancellation_source</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">is_cancellation_requested</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">can_be_cancelled</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">request_cancellation</span><span class="p">();</span>

   <span class="n">cancellation_token</span> <span class="nf">token</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">cancellation_token</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="c1">// 构造一个无法被撤销的令牌</span>
   <span class="n">cancellation_token</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">cancellation_token</span><span class="p">(</span><span class="k">const</span> <span class="n">cancellation_token</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">cancellation_token</span><span class="p">(</span><span class="n">cancellation_token</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="o">~</span><span class="n">cancellation_token</span><span class="p">();</span>

   <span class="n">cancellation_token</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">cancellation_token</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">cancellation_token</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">cancellation_token</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">is_cancellation_requested</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">throw_if_cancellation_requested</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="c1">// 查询此令牌是否有取消请求。</span>
   <span class="c1">// 当函数调用无需撤销时，代码可据此设置更有效的 code-path</span>
   <span class="kt">bool</span> <span class="nf">can_be_cancelled</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// RAII 类。用于注册在撤销时调用的回调函数</span>
<span class="k">class</span> <span class="nc">cancellation_registration</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="c1">// 注册一个在撤销时调用的回调函数</span>
   <span class="c1">// 如果还没有请求撤销，则在调用 request_cancellation() 的线程上调用回调函数，否则在此线程内立即调用回调函数</span>
   <span class="c1">// 回调函数不得抛出异常</span>
   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">CALLBACK</span><span class="o">&gt;</span>
   <span class="n">cancellation_registration</span><span class="p">(</span><span class="n">cancellation_token</span> <span class="n">token</span><span class="p">,</span> <span class="n">CALLBACK</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">);</span>

   <span class="n">cancellation_registration</span><span class="p">(</span><span class="k">const</span> <span class="n">cancellation_registration</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="o">~</span><span class="n">cancellation_registration</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">operation_cancelled</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">operation_cancelled</span><span class="p">();</span>
   <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：论询方式</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">do_something_async</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">cancellation_token</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// 通过调用 throw_if_cancellation_requested() 在函数内显式创建一个可撤销点</span>
<span class="n">token</span><span class="p">.</span><span class="n">throw_if_cancellation_requested</span><span class="p">();</span>

<span class="n">co_await</span> <span class="nf">do_step_1</span><span class="p">();</span>

<span class="n">token</span><span class="p">.</span><span class="n">throw_if_cancellation_requested</span><span class="p">();</span>

<span class="n">do_step_2</span><span class="p">();</span>

<span class="c1">// 可选的。通过查询是否有撤销请求以在函数返回前进行清理工作</span>
<span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">is_cancellation_requested</span><span class="p">())</span>
<span class="p">{</span>
   <span class="n">display_message_to_user</span><span class="p">(</span><span class="s">&quot;Cancelling operation...&quot;</span><span class="p">);</span>
   <span class="n">do_cleanup</span><span class="p">();</span>
   <span class="k">throw</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">operation_cancelled</span><span class="p">{};</span>
<span class="p">}</span>

<span class="n">do_final_step</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：回调方式</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 假设我们现在有一个定时器，其具有撤销 API，但是还不支持撤销令牌。</span>
<span class="c1">// 我们可以使用一个 cancellation_registration 对象来注册一个回调函数，在回调函数内可调用已经存在的撤销 API</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">cancellable_timer_wait</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">cancellation_token</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">auto</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">create_timer</span><span class="p">(</span><span class="mi">10</span><span class="n">s</span><span class="p">);</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">cancellation_registration</span> <span class="n">registration</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
<span class="p">{</span>
   <span class="c1">// 调用已经存在的定时器撤销 API</span>
   <span class="n">timer</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
<span class="p">});</span>

<span class="n">co_await</span> <span class="n">timer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cancellation-source">
<h3><a class="toc-backref" href="#id38">cancellation_source</a><a class="headerlink" href="#cancellation-source" title="Permalink to this headline">¶</a></h3>
<p>此处原文档尚未更新</p>
</div>
<div class="section" id="cancellation-registration">
<h3><a class="toc-backref" href="#id39">cancellation_registration</a><a class="headerlink" href="#cancellation-registration" title="Permalink to this headline">¶</a></h3>
<p>此处原文档尚未更新</p>
</div>
</div>
<div class="section" id="i-o">
<h2><a class="toc-backref" href="#id40">I/O 调度</a><a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h2>
<div class="section" id="static-thread-pool">
<h3><a class="toc-backref" href="#id41">static_thread_pool</a><a class="headerlink" href="#static-thread-pool" title="Permalink to this headline">¶</a></h3>
<p><abbr title="Static Thread Pool">静态线程池</abbr> 提供了一个抽象，以允许你的调度工作运行在一个固定尺寸的线程池中。</p>
<p>这个类实现了 <code class="docutils literal notranslate"><span class="pre">Scheduler</span></code> 概念（如下）</p>
<p>你可以通过调用 <code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">threadPool.schedule()</span></code> 向线程池中添加任务。这个操作将会挂起当前协程、将它放入线程池的工作队列中。当线程池中有空闲线程可用于此协程时，将会恢复协程。 <strong>此操作保证不发生异常。通常情况下也不会分配内存</strong></p>
<p>该类利用 <abbr title="Work-Stealing">工作窃取</abbr> 算法在多个线程之间实现负载均衡。从线程池线程进入到线程池的任务将被调度到此线程独自的 FIFO 队列中，这意味着任务将在与原线程相同的线程上执行。而从外部进入到线程池中的任务，将进入一个全局的 FIFO 队列中。如果一个工作线程在它的本地队列中已经完成了工作，它会首先从全局队列中出列。如果本地队列为空，它会排在全局队列末尾以窃取工作。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">static_thread_pool</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="c1">// 初始化线程池对象并使用 std::thread::hardware_concurrency() 来设定线程池的线程数量</span>
   <span class="n">static_thread_pool</span><span class="p">();</span>

   <span class="c1">// 以指定数量的线程来初始化线程池</span>
   <span class="k">explicit</span> <span class="nf">static_thread_pool</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">threadCount</span><span class="p">);</span>

   <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">thread_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">class</span> <span class="nc">schedule_operation</span>
   <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">schedule_operation</span><span class="p">(</span><span class="n">static_thread_pool</span><span class="o">*</span> <span class="n">tp</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

      <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">private</span><span class="o">:</span>
      <span class="c1">// 未指定</span>
   <span class="p">};</span>

   <span class="c1">// 返回一个可被协程 await 的操作</span>
   <span class="c1">//</span>
   <span class="c1">//</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">schedule_operation</span> <span class="n">schedule</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>

   <span class="c1">// 未指定</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>简单例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">do_something_on_threadpool</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">static_thread_pool</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// 首先将协程调入到线程池中</span>
<span class="n">co_await</span> <span class="n">tp</span><span class="p">.</span><span class="n">schedule</span><span class="p">();</span>

<span class="c1">// 当恢复时，此线程将运行在线程池中</span>
<span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：对静态线程池运行 <code class="docutils literal notranslate"><span class="pre">schedule_on()</span></code> 以并行执行任务</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">dot_product</span><span class="p">(</span><span class="n">static_thread_pool</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">b</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// 将任务递归地细分为两个相同大小的任务</span>
   <span class="c1">// 第一个任务将会运行到线程池中</span>
   <span class="c1">// 第二个任务在此线程中继续执行</span>
   <span class="kt">size_t</span> <span class="n">halfCount</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
   <span class="k">auto</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">when_all</span><span class="p">(</span>
      <span class="n">schedule_on</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dot_product</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">halfCount</span><span class="p">),</span>
      <span class="n">dot_product</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">halfCount</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">halfCount</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">halfCount</span><span class="p">));</span>
   <span class="n">co_return</span> <span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
   <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
   <span class="p">}</span>
   <span class="n">co_return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="io-service-and-io-work-scope">
<h3><a class="toc-backref" href="#id42">io_service and io_work_scope</a><a class="headerlink" href="#io-service-and-io-work-scope" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">io_service</span></code> 类为处理异步 I/O 操作完成事件提供了抽象。</p>
<p>当 I/O 操作完成时，await 其的协程将会在 I/O 线程的以下事件处理函数中被恢复： <code class="docutils literal notranslate"><span class="pre">process_events()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">process_pending_events()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">process_one_event()</span></code>  、 <code class="docutils literal notranslate"><span class="pre">process_one_pending_event()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">io_service</span></code> 类不会管理任何 I/O 线程。你必须确保为 await 的协程而调用的事件处理函数被 dispatch。要么用独立的线程调用 <code class="docutils literal notranslate"><span class="pre">process_events()</span></code> ，要么将其与其他事件循环混用（比如 UI 事件循环）并周期性地调用 <code class="docutils literal notranslate"><span class="pre">process_pending_events()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">process_one_pending_event()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">io_service</span></code> 可以被集成到其他事件循环中，比如 UI 事件循环。</p>
<p>通过多个线程调用 <code class="docutils literal notranslate"><span class="pre">process_events()</span></code> 函数，你可以同时处理多个事件。在 <code class="docutils literal notranslate"><span class="pre">io_service</span></code> 构造时，你也可以为其传入一个参数，以示意最多应当能有多少个同时运行的事件处理函数。</p>
<p>在 Windows 上，此实现充分利用了 <abbr title="Windows I/O Completion Port">Windows I/O 完成端口</abbr> 以可拓展的方式向 I/O 线程分发事件。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">io_service</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="k">class</span> <span class="nc">schedule_operation</span><span class="p">;</span>
   <span class="k">class</span> <span class="nc">timed_schedule_operation</span><span class="p">;</span>

   <span class="n">io_service</span><span class="p">();</span>
   <span class="n">io_service</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">concurrencyHint</span><span class="p">);</span>

   <span class="n">io_service</span><span class="p">(</span><span class="n">io_service</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">io_service</span><span class="p">(</span><span class="k">const</span> <span class="n">io_service</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">io_service</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">io_service</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">io_service</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">io_service</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="o">~</span><span class="n">io_service</span><span class="p">();</span>

   <span class="c1">// 调度器方法</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">schedule_operation</span> <span class="n">schedule</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">REP</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RATIO</span><span class="o">&gt;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">timed_schedule_operation</span> <span class="n">schedule_after</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">REP</span><span class="p">,</span> <span class="n">RATIO</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">,</span>
      <span class="n">cppcoro</span><span class="o">::</span><span class="n">cancellation_token</span> <span class="n">cancellationToken</span> <span class="o">=</span> <span class="p">{})</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 事件循环方法</span>
   <span class="c1">//</span>
   <span class="c1">// I/O 线程必须调用这些方法来处理 I/O 事件并运行被调度的线程</span>
   <span class="c1">// scheduled coroutines.</span>

   <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">process_events</span><span class="p">();</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">process_pending_events</span><span class="p">();</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">process_one_event</span><span class="p">();</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">process_one_pending_event</span><span class="p">();</span>

   <span class="c1">// 这里要求所有事件处理线程都已经退出它们的事件循环</span>
   <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 查询孙是否有线程调用过 stop()</span>
   <span class="kt">bool</span> <span class="nf">is_stop_requested</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 重置调用过 stop() 的事件循环，以让其可以再次处理事件</span>
   <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>

   <span class="c1">// 使用引用计数的方式追踪外部对 io_service 的引用</span>
   <span class="c1">//</span>
   <span class="c1">// 当引用计数递减为零时，io_service::stop() 将被调用</span>
   <span class="c1">//</span>
   <span class="c1">// 当 进入/退出 作用域时，使用 RAII 类 io_work_scope 来管理这些方法的调用</span>
   <span class="kt">void</span> <span class="nf">notify_work_started</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">notify_work_finished</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">io_service</span><span class="o">::</span><span class="n">schedule_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">schedule_operation</span><span class="p">(</span><span class="k">const</span> <span class="n">schedule_operation</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">schedule_operation</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">schedule_operation</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">io_service</span><span class="o">::</span><span class="n">timed_schedule_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">timed_schedule_operation</span><span class="p">(</span><span class="n">timed_schedule_operation</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">timed_schedule_operation</span><span class="p">(</span><span class="k">const</span> <span class="n">timed_schedule_operation</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">timed_schedule_operation</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">timed_schedule_operation</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
   <span class="n">timed_schedule_operation</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">timed_schedule_operation</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">);</span>
   <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">io_work_scope</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="n">io_work_scope</span><span class="p">(</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">io_work_scope</span><span class="p">(</span><span class="k">const</span> <span class="n">io_work_scope</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">io_work_scope</span><span class="p">(</span><span class="n">io_work_scope</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="o">~</span><span class="n">io_work_scope</span><span class="p">();</span>

   <span class="n">io_work_scope</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">io_work_scope</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">io_work_scope</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">io_work_scope</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">io_service</span><span class="o">&amp;</span> <span class="n">service</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cppcoro/task.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/task.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/io_service.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/read_only_file.hpp&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;experimental/filesystem&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">filesystem</span><span class="p">;</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">count_lines</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">,</span> <span class="n">fs</span><span class="o">::</span><span class="n">path</span> <span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">auto</span> <span class="n">file</span> <span class="o">=</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">read_only_file</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="n">ioService</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">bufferSize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bufferSize</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">newlineCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fileSize</span> <span class="o">=</span> <span class="n">file</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">fileSize</span><span class="p">;)</span>
<span class="p">{</span>
   <span class="k">const</span> <span class="k">auto</span> <span class="n">bytesToRead</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bufferSize</span><span class="p">,</span> <span class="n">fileSize</span> <span class="o">-</span> <span class="n">offset</span><span class="p">));</span>

   <span class="k">const</span> <span class="k">auto</span> <span class="n">bytesRead</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">buffer</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">bytesToRead</span><span class="p">);</span>

   <span class="n">newlineCount</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">buffer</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">bytesRead</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

   <span class="n">offset</span> <span class="o">+=</span> <span class="n">bytesRead</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">co_return</span> <span class="n">newlineCount</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">run</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">io_work_scope</span> <span class="n">ioScope</span><span class="p">(</span><span class="n">ioService</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">lineCount</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">count_lines</span><span class="p">(</span><span class="n">ioService</span><span class="p">,</span> <span class="n">fs</span><span class="o">::</span><span class="n">path</span><span class="p">{</span><span class="s">&quot;foo.txt&quot;</span><span class="p">});</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;foo.txt has &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">lineCount</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; lines.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;;</span>
<span class="p">}</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">process_events</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// 处理事件至 io_service 被停止时</span>
<span class="c1">// 比如：当最后一个 io_work_scope 退出作用域时</span>
<span class="n">ioService</span><span class="p">.</span><span class="n">process_events</span><span class="p">();</span>
<span class="n">co_return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ioService</span><span class="p">;</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">sync_wait</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">when_all_ready</span><span class="p">(</span>
   <span class="n">run</span><span class="p">(</span><span class="n">ioService</span><span class="p">),</span>
   <span class="n">process_events</span><span class="p">(</span><span class="n">ioService</span><span class="p">)));</span>

<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>io_service 作为调度器</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">io_service</span></code> 实现了 <code class="docutils literal notranslate"><span class="pre">Scheduler</span></code> 和 <code class="docutils literal notranslate"><span class="pre">DelayedScheduler</span></code> <abbr title="Concepts">概念</abbr></p>
<p>这允许协程在当前线程暂停运行，并在一个与 <code class="docutils literal notranslate"><span class="pre">io_service</span></code> 相关联的 I/O 线程中被唤醒。</p>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">do_something</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// 协程在被 await 的线程中开始运行</span>

<span class="c1">// 通过 await io_service::schedule() 的结果，协程可以转移到 I/O 线程中运行</span>
<span class="n">co_await</span> <span class="n">ioService</span><span class="p">.</span><span class="n">schedule</span><span class="p">();</span>

<span class="c1">// 此时，此协程运行在调用了 io_service 事件处理函数的 I/O 线程中</span>

<span class="c1">// 协程也可以使用一个 Delayed-Schedule 的动作。当 I/O 线程恢复它时，它会延迟指定的时间。</span>
<span class="n">co_await</span> <span class="n">ioService</span><span class="p">.</span><span class="n">schedule_after</span><span class="p">(</span><span class="mi">100</span><span class="n">ms</span><span class="p">);</span>

<span class="c1">// 此处，协程应该运行在一个不同的 I/O 线程中</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="file-readable-file-writable-file">
<h3><a class="toc-backref" href="#id43">file, readable_file, writable_file</a><a class="headerlink" href="#file-readable-file-writable-file" title="Permalink to this headline">¶</a></h3>
<p>这些抽象基类用于表现具体的文件 I/O</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">file_read_operation</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">file_write_operation</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">file</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="k">virtual</span> <span class="o">~</span><span class="n">file</span><span class="p">();</span>

   <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>

   <span class="n">file</span><span class="p">(</span><span class="n">file</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">readable_file</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">file</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">file_read_operation</span> <span class="n">read</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">offset</span><span class="p">,</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">byteCount</span><span class="p">,</span>
      <span class="n">cancellation_token</span> <span class="n">ct</span> <span class="o">=</span> <span class="p">{})</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">writable_file</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">file</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="kt">void</span> <span class="n">set_size</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">fileSize</span><span class="p">);</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">file_write_operation</span> <span class="n">write</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">offset</span><span class="p">,</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">byteCount</span><span class="p">,</span>
      <span class="n">cancellation_token</span> <span class="n">ct</span> <span class="o">=</span> <span class="p">{})</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">file_read_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="n">file_read_operation</span><span class="p">(</span><span class="n">file_read_operation</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">await_resume</span><span class="p">();</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">file_write_operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="n">file_write_operation</span><span class="p">(</span><span class="n">file_write_operation</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaiter</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">await_resume</span><span class="p">();</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="read-only-file-write-only-file-read-write-file">
<h3><a class="toc-backref" href="#id44">read_only_file, write_only_file, read_write_file</a><a class="headerlink" href="#read-only-file-write-only-file-read-write-file" title="Permalink to this headline">¶</a></h3>
<p>这些类型代表了具体的文件 I/O 类：</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">read_only_file</span> <span class="o">:</span> <span class="k">public</span> <span class="n">readable_file</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="k">static</span> <span class="n">read_only_file</span> <span class="n">open</span><span class="p">(</span>
      <span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span>
      <span class="n">file_share_mode</span> <span class="n">shareMode</span> <span class="o">=</span> <span class="n">file_share_mode</span><span class="o">::</span><span class="n">read</span><span class="p">,</span>
      <span class="n">file_buffering_mode</span> <span class="n">bufferingMode</span> <span class="o">=</span> <span class="n">file_buffering_mode</span><span class="o">::</span><span class="n">default_</span><span class="p">);</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">write_only_file</span> <span class="o">:</span> <span class="k">public</span> <span class="n">writable_file</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="k">static</span> <span class="n">write_only_file</span> <span class="n">open</span><span class="p">(</span>
      <span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span>
      <span class="n">file_open_mode</span> <span class="n">openMode</span> <span class="o">=</span> <span class="n">file_open_mode</span><span class="o">::</span><span class="n">create_or_open</span><span class="p">,</span>
      <span class="n">file_share_mode</span> <span class="n">shareMode</span> <span class="o">=</span> <span class="n">file_share_mode</span><span class="o">::</span><span class="n">none</span><span class="p">,</span>
      <span class="n">file_buffering_mode</span> <span class="n">bufferingMode</span> <span class="o">=</span> <span class="n">file_buffering_mode</span><span class="o">::</span><span class="n">default_</span><span class="p">);</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">read_write_file</span> <span class="o">:</span> <span class="k">public</span> <span class="n">readable_file</span><span class="p">,</span> <span class="k">public</span> <span class="n">writable_file</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="k">static</span> <span class="n">read_write_file</span> <span class="n">open</span><span class="p">(</span>
      <span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioService</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span>
      <span class="n">file_open_mode</span> <span class="n">openMode</span> <span class="o">=</span> <span class="n">file_open_mode</span><span class="o">::</span><span class="n">create_or_open</span><span class="p">,</span>
      <span class="n">file_share_mode</span> <span class="n">shareMode</span> <span class="o">=</span> <span class="n">file_share_mode</span><span class="o">::</span><span class="n">none</span><span class="p">,</span>
      <span class="n">file_buffering_mode</span> <span class="n">bufferingMode</span> <span class="o">=</span> <span class="n">file_buffering_mode</span><span class="o">::</span><span class="n">default_</span><span class="p">);</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>所有的 <code class="docutils literal notranslate"><span class="pre">open()</span></code> 函数在出错时都会抛出 <code class="docutils literal notranslate"><span class="pre">std::system_error</span></code> 异常。</p>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id45">网络</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>注意:目前仅支持 Windows 平台上的网络抽象。Linux 支持将会在稍后推出。</p>
<div class="section" id="socket">
<h3><a class="toc-backref" href="#id46">socket</a><a class="headerlink" href="#socket" title="Permalink to this headline">¶</a></h3>
<p>套接字类可用于通过网络异步发送/接收数据</p>
<p>当前只支持 IPv4 和 IPv6 上的 TCP/IP, UDP/IP 协议。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/net/socket.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">net</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">socket</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="k">static</span> <span class="n">socket</span> <span class="n">create_tcpv4</span><span class="p">(</span><span class="n">ip_service</span><span class="o">&amp;</span> <span class="n">ioSvc</span><span class="p">);</span>
   <span class="k">static</span> <span class="n">socket</span> <span class="nf">create_tcpv6</span><span class="p">(</span><span class="n">ip_service</span><span class="o">&amp;</span> <span class="n">ioSvc</span><span class="p">);</span>
   <span class="k">static</span> <span class="n">socket</span> <span class="nf">create_updv4</span><span class="p">(</span><span class="n">ip_service</span><span class="o">&amp;</span> <span class="n">ioSvc</span><span class="p">);</span>
   <span class="k">static</span> <span class="n">socket</span> <span class="nf">create_udpv6</span><span class="p">(</span><span class="n">ip_service</span><span class="o">&amp;</span> <span class="n">ioSvc</span><span class="p">);</span>

   <span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="o">~</span><span class="n">socket</span><span class="p">();</span>

   <span class="n">socket</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">socket</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">// 返回套接字的平台相关的原声句柄</span>
   <span class="o">&lt;</span><span class="n">platform</span><span class="o">-</span><span class="n">specific</span><span class="o">&gt;</span> <span class="n">native_handle</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">local_endpoint</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">remote_endpoint</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">bind</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">localEndPoint</span><span class="p">);</span>

   <span class="kt">void</span> <span class="nf">listen</span><span class="p">();</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">connect</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">remoteEndPoint</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">connect</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">remoteEndPoint</span><span class="p">,</span>
                           <span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">accept</span><span class="p">(</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">acceptingSocket</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">accept</span><span class="p">(</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">acceptingSocket</span><span class="p">,</span>
                           <span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">disconnect</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">disconnect</span><span class="p">(</span><span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
                              <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
                              <span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">recv</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">recv</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
                              <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
                              <span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">socket_recv_from_operation</span> <span class="n">recv_from</span><span class="p">(</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">socket_recv_from_operation_cancellable</span> <span class="n">recv_from</span><span class="p">(</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
      <span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">socket_send_to_operation</span> <span class="n">send_to</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">destination</span><span class="p">,</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span>
   <span class="n">socket_send_to_operation_cancellable</span> <span class="n">send_to</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">destination</span><span class="p">,</span>
      <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
      <span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">void</span> <span class="nf">close_send</span><span class="p">();</span>
   <span class="kt">void</span> <span class="nf">close_recv</span><span class="p">();</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子： echo 服务器</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cppcoro/net/socket.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/io_service.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/cancellation_source.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/async_scope.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cppcoro/on_scope_exit.hpp&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">handle_connection</span><span class="p">(</span><span class="n">socket</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">try</span>
<span class="p">{</span>
   <span class="k">const</span> <span class="kt">size_t</span> <span class="n">bufferSize</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
   <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bufferSize</span><span class="p">);</span>
   <span class="kt">size_t</span> <span class="n">bytesRead</span><span class="p">;</span>
   <span class="k">do</span> <span class="p">{</span>
      <span class="c1">// 读取一些字节</span>
      <span class="n">bytesRead</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">s</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">bufferSize</span><span class="p">);</span>

      <span class="c1">// 写入一些字节</span>
      <span class="kt">size_t</span> <span class="n">bytesWritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">bytesWritten</span> <span class="o">&lt;</span> <span class="n">bytesRead</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">bytesWritten</span> <span class="o">+=</span> <span class="n">co_await</span> <span class="n">s</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
         <span class="n">buffer</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">bytesWritten</span><span class="p">,</span>
         <span class="n">bytesRead</span> <span class="o">-</span> <span class="n">bytesWritten</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bytesRead</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

   <span class="n">s</span><span class="p">.</span><span class="n">close_send</span><span class="p">();</span>

   <span class="n">co_await</span> <span class="n">s</span><span class="p">.</span><span class="n">disconnect</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;connection failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">echo_server</span><span class="p">(</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">net</span><span class="o">::</span><span class="n">ipv4_endpoint</span> <span class="n">endpoint</span><span class="p">,</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">ioSvc</span><span class="p">,</span>
<span class="n">cancellation_token</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">async_scope</span> <span class="n">scope</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">ex</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
   <span class="k">auto</span> <span class="n">listeningSocket</span> <span class="o">=</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">net</span><span class="o">::</span><span class="n">socket</span><span class="o">::</span><span class="n">create_tcpv4</span><span class="p">(</span><span class="n">ioSvc</span><span class="p">);</span>
   <span class="n">listeningSocket</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">endpoint</span><span class="p">);</span>
   <span class="n">listeningSocket</span><span class="p">.</span><span class="n">listen</span><span class="p">();</span>

   <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">net</span><span class="o">::</span><span class="n">socket</span><span class="o">::</span><span class="n">create_tcpv4</span><span class="p">(</span><span class="n">ioSvc</span><span class="p">);</span>
      <span class="n">co_await</span> <span class="n">listeningSocket</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
      <span class="n">scope</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">handle_connection</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">connection</span><span class="p">)));</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">operation_cancelled</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
   <span class="n">ex</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Wait until all handle_connection tasks have finished.</span>
<span class="n">co_await</span> <span class="n">scope</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
   <span class="n">cppcoro</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ioSvc</span><span class="p">;</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

   <span class="k">auto</span> <span class="n">endpoint</span> <span class="o">=</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">ipv4_endpoint</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">endpoint</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

   <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">sync_wait</span><span class="p">(</span><span class="n">cppcoro</span><span class="o">::</span><span class="n">when_all</span><span class="p">(</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">task</span><span class="o">&lt;&gt;</span>
      <span class="p">{</span>
            <span class="c1">// Shutdown the event loop once finished.</span>
            <span class="k">auto</span> <span class="n">stopOnExit</span> <span class="o">=</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">on_scope_exit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="n">ioSvc</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span> <span class="p">});</span>

            <span class="n">cppcoro</span><span class="o">::</span><span class="n">cancellation_source</span> <span class="n">canceller</span><span class="p">;</span>
            <span class="n">co_await</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">when_all</span><span class="p">(</span>
               <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">task</span><span class="o">&lt;&gt;</span>
               <span class="p">{</span>
                  <span class="c1">// Run for 30s then stop accepting new connections.</span>
                  <span class="n">co_await</span> <span class="n">ioSvc</span><span class="p">.</span><span class="n">schedule_after</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span>
                  <span class="n">canceller</span><span class="p">.</span><span class="n">request_cancellation</span><span class="p">();</span>
               <span class="p">}(),</span>
               <span class="n">echo_server</span><span class="p">(</span><span class="o">*</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">ioSvc</span><span class="p">,</span> <span class="n">canceller</span><span class="p">.</span><span class="n">token</span><span class="p">()));</span>
      <span class="p">}(),</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">task</span><span class="o">&lt;&gt;</span>
      <span class="p">{</span>
            <span class="n">ioSvc</span><span class="p">.</span><span class="n">process_events</span><span class="p">();</span>
      <span class="p">}()));</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ip-address-ipv4-address-ipv6-address">
<h3><a class="toc-backref" href="#id47">ip_address, ipv4_address, ipv6_address</a><a class="headerlink" href="#ip-address-ipv4-address-ipv6-address" title="Permalink to this headline">¶</a></h3>
<p>表示IP地址的辅助类</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">net</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">ipv4_address</span>
<span class="p">{</span>
   <span class="k">using</span> <span class="n">bytes_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">constexpr</span> <span class="n">ipv4_address</span><span class="p">();</span>
   <span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">ipv4_address</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">integer</span><span class="p">);</span>
   <span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">ipv4_address</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="p">)[</span><span class="mi">4</span><span class="p">]);</span>
   <span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">ipv4_address</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">b0</span><span class="p">,</span>
                                    <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">b1</span><span class="p">,</span>
                                    <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">b2</span><span class="p">,</span>
                                    <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">b3</span><span class="p">);</span>

   <span class="k">constexpr</span> <span class="k">const</span> <span class="n">bytes_t</span><span class="o">&amp;</span> <span class="n">bytes</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">to_integer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">static</span> <span class="k">constexpr</span> <span class="n">ipv4_address</span> <span class="nf">loopback</span><span class="p">();</span>

   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">is_loopback</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">is_private_network</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">();</span>

   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ipv4_address</span><span class="o">&gt;</span> <span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">string</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ipv6_address</span>
<span class="p">{</span>
   <span class="k">using</span> <span class="n">bytes_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">constexpr</span> <span class="n">ipv6_address</span><span class="p">();</span>

   <span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">ipv6_address</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">subnetPrefix</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">interfaceIdentifier</span><span class="p">);</span>

   <span class="k">constexpr</span> <span class="nf">ipv6_address</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part0</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part1</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part2</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part3</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part4</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part5</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part6</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">part7</span><span class="p">);</span>

   <span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">ipv6_address</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parts</span><span class="p">)[</span><span class="mi">8</span><span class="p">]);</span>

   <span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">ipv6_address</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">bytes</span><span class="p">)[</span><span class="mi">16</span><span class="p">]);</span>

   <span class="k">constexpr</span> <span class="k">const</span> <span class="n">bytes_t</span><span class="o">&amp;</span> <span class="n">bytes</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">subnet_prefix</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">interface_identifier</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">static</span> <span class="k">constexpr</span> <span class="n">ipv6_address</span> <span class="nf">unspecified</span><span class="p">();</span>
   <span class="k">static</span> <span class="k">constexpr</span> <span class="n">ipv6_address</span> <span class="nf">loopback</span><span class="p">();</span>

   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ipv6_address</span><span class="o">&gt;</span> <span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">string</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">ip_address</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

   <span class="c1">// 构造一个地址为 0.0.0.0 的 IPv4地址</span>
   <span class="n">ip_address</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">ip_address</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">address</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">ip_address</span><span class="p">(</span><span class="n">ipv6_address</span> <span class="n">address</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">is_ipv4</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">is_ipv6</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">const</span> <span class="n">ipv4_address</span><span class="o">&amp;</span> <span class="n">to_ipv4</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">to_ipv6</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">bytes</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ip_address</span><span class="o">&gt;</span> <span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">string</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_address</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_address</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">//  ipv4_address sorts less than ipv6_address</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_address</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_address</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_address</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_address</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ip-endpoint-ipv4-endpoint-ipv6-endpoint">
<h3><a class="toc-backref" href="#id48">ip_endpoint, ipv4_endpoint, ipv6_endpoint</a><a class="headerlink" href="#ip-endpoint-ipv4-endpoint-ipv6-endpoint" title="Permalink to this headline">¶</a></h3>
<p>表示IP地址和端口号的辅助类</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">net</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">ipv4_endpoint</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">ipv4_endpoint</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">explicit</span> <span class="nf">ipv4_endpoint</span><span class="p">(</span><span class="n">ipv4_address</span> <span class="n">address</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">const</span> <span class="n">ipv4_address</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">port</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ipv4_endpoint</span><span class="o">&gt;</span> <span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">string</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">ipv6_endpoint</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">ipv6_endpoint</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="k">explicit</span> <span class="nf">ipv6_endpoint</span><span class="p">(</span><span class="n">ipv6_address</span> <span class="n">address</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">const</span> <span class="n">ipv6_address</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">port</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ipv6_endpoint</span><span class="o">&gt;</span> <span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">string</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">ip_endpoint</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="c1">//构造一个地址为 0.0.0.0:0 的 IPv4 终端</span>
   <span class="n">ip_endpoint</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">ip_endpoint</span><span class="p">(</span><span class="n">ipv4_endpoint</span> <span class="n">endpoint</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">ip_endpoint</span><span class="p">(</span><span class="n">ipv6_endpoint</span> <span class="n">endpoint</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="nf">is_ipv4</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="nf">is_ipv6</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="k">const</span> <span class="n">ipv4_endpoint</span><span class="o">&amp;</span> <span class="n">to_ipv4</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
   <span class="k">const</span> <span class="n">ipv6_endpoint</span><span class="o">&amp;</span> <span class="n">to_ipv6</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="n">ip_address</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">port</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ip_endpoint</span><span class="o">&gt;</span> <span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">string</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

   <span class="c1">//  IPv4 终端排序时要小于 IPv6 终端</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ip_endpoint</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id49">函数</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sync-wait">
<h3><a class="toc-backref" href="#id50">sync_wait()</a><a class="headerlink" href="#sync-wait" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">sync_wait()</span></code> 能被用于同步 wait 直到指定的 <code class="docutils literal notranslate"><span class="pre">awaitable</span></code> 完成。</p>
<p>指定的 awaitable 将会在当前线程新建的一个协程内被 <code class="docutils literal notranslate"><span class="pre">co_await</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">sync_wait()</span></code> 的调用将会阻塞线程至操作完成。结果要么返回 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 的结果，要么重新抛出未捕获异常。</p>
<p><code class="docutils literal notranslate"><span class="pre">sync_wait()</span></code> 一般用于等待 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 中顶层任务的完成，实际上它也是启动顶层 <code class="docutils literal notranslate"><span class="pre">task</span></code> 的唯一方法。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/sync_wait.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">AWAITABLE</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">sync_wait</span><span class="p">(</span><span class="n">AWAITABLE</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&amp;&amp;&gt;::</span><span class="n">await_result_t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">example_task</span><span class="p">()</span>
<span class="p">{</span>
<span class="k">auto</span> <span class="n">makeTask</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="p">{</span>
   <span class="n">co_return</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">task</span> <span class="o">=</span> <span class="n">makeTask</span><span class="p">();</span>

<span class="c1">// 启动此“惰性任务”并等待它完成</span>
<span class="n">sync_wait</span><span class="p">(</span><span class="n">task</span><span class="p">);</span> <span class="c1">// -&gt; &quot;foo&quot;</span>
<span class="n">sync_wait</span><span class="p">(</span><span class="n">makeTask</span><span class="p">());</span> <span class="c1">// -&gt; &quot;foo&quot;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">example_shared_task</span><span class="p">()</span>
<span class="p">{</span>
<span class="k">auto</span> <span class="n">makeTask</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">shared_task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="p">{</span>
   <span class="n">co_return</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">task</span> <span class="o">=</span> <span class="n">makeTask</span><span class="p">();</span>
<span class="c1">// 启动此共享任务并等待它完成</span>
<span class="n">sync_wait</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="n">sync_wait</span><span class="p">(</span><span class="n">makeTask</span><span class="p">())</span> <span class="o">==</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="when-all">
<h3><a class="toc-backref" href="#id51">when_all()</a><a class="headerlink" href="#when-all" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">when_all()</span></code> 可以用于创建一个新的 Awaitable 对象，当其被 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 时，将会并发 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 所有输入的任务并返回一个他们结果的集合。</p>
<p>当返回的 Awaitable 对象被  <code class="docutils literal notranslate"><span class="pre">co_await</span></code>  时，它将在当前线程上 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 每个输入的任务。一旦第一个任务完成，就会启动第二个任务，依此类推。这些操作并发地执行，直到它们全部运行完成。</p>
<p>一旦所有任务 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 操作都完成，就会从每个单独的结果构建一个结果集。任何输入任务抛出异常，或者结果集的构造抛出了异常，那么该异常将被返回的 Awaitable 对象的 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 表达式重新抛出。</p>
<p>若多个 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 由于异常而被终止，其中之一将从 <code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">when_all()</span></code> 传播出去，而其他异常将被忽略。具体是那个异常是在运行时决定。</p>
<p>如果要知道哪个任务 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 操作失败，或者即使其中一些操作失败也希望继续获取其他操作的结果，那么您应该使用 <code class="docutils literal notranslate"><span class="pre">when_all_ready()</span></code> 。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/when_all.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="c1">// 变参版本</span>
<span class="c1">//</span>
<span class="c1">// 注意：如果一些任务 `co_await` 表达式结果类型为 void，则构造</span>
<span class="c1">// 的结果集中，其结果将使用一个空的结构体 detail::void_value 进行填充</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">AWAITABLES</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">when_all</span><span class="p">(</span><span class="n">AWAITABLES</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">awaitables</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLES</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// 重载版本 vector&lt;Awaitable&lt;void&gt;&gt;.</span>
<span class="k">template</span><span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="p">,</span>
   <span class="k">typename</span> <span class="n">RESULT</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="p">,</span>
   <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_void_v</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">when_all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;</span> <span class="n">awaitables</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 重载 vector&lt;Awaitable&lt;NonVoid&gt;&gt; ，在被等待时产生一个值</span>
<span class="k">template</span><span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="p">,</span>
   <span class="k">typename</span> <span class="n">RESULT</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="p">,</span>
   <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_void_v</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">when_all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;</span> <span class="n">awaitables</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span>
         <span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference_v</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;&gt;</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">task</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">get_a</span><span class="p">();</span>
<span class="n">task</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">get_b</span><span class="p">();</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">example1</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 并发运行 get_a() 和 get_b()</span>
<span class="c1">// 产生的结果类型为 std::tuple&lt;A, B&gt;，其可使用结构化绑定进行解包。</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">when_all</span><span class="p">(</span><span class="n">get_a</span><span class="p">(),</span> <span class="n">get_b</span><span class="p">());</span>

<span class="c1">// 使用 a, b</span>
<span class="p">}</span>

<span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">get_record</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">);</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">example2</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">tasks</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">tasks</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">get_record</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// 并发运行所有的 get_record() 任务</span>
<span class="c1">// 如果有任务发生了异常，那么在它们都完成时，将会将异常从</span>
<span class="c1">//  co_await 表达式中传播出去</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">when_all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tasks</span><span class="p">));</span>

<span class="c1">// 处理结果集</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">records</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="when-all-ready">
<h3><a class="toc-backref" href="#id52">when_all_ready()</a><a class="headerlink" href="#when-all-ready" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">when_all_ready()</span></code> 可以用于创建一个新的 Awaitable 对象，其将会在所有输入的 Awaitable 对象完成后才完成</p>
<p>输入任务可以是 Awaitable 的任何类型</p>
<p>当返回的 Awaitable 对象 <a class="footnote-reference brackets" href="#id8" id="id7">1</a> 被 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> ，其将按照线程传入 <code class="docutils literal notranslate"><span class="pre">when_all_ready()</span></code> 的顺序依次 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 线程。如果这些任务不能同步完成，那么它们将并发执行。</p>
<p>一旦所有输入的任务都完成，则返回的 Awaitable 对象将会恢复挂起的协程。挂起的协程将在所有输入任务都完成后才被恢复。</p>
<p>返回的 Awaitable 保证不抛出异常，即使输入的任务可能抛出异常。</p>
<p>注意：调用 <code class="docutils literal notranslate"><span class="pre">when_all_ready()</span></code> 可能由于内存不足而抛出 <code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code> 异常。而且还可能由于调用输入任务的拷贝/移动构造函数而抛出异常。</p>
<p><code class="docutils literal notranslate"><span class="pre">co_await</span></code> 返回的 Awaitable 对象的结果是返回一个 <code class="docutils literal notranslate"><span class="pre">when_all_task&lt;RESULT&gt;</span></code> 类型的 <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> 或 <code class="docutils literal notranslate"><span class="pre">std::vector&gt;</span></code> 。 这些对象允许您通过调用 <code class="docutils literal notranslate"><span class="pre">hen_all_task&lt;RESULT&gt;::result()</span></code> 分别获得每个输入 Awaitable 对象的结果(或异常)。这允许调用方同时等待多个可等待对象，并在它们完成时进行同步，同时仍保留随后检查每个 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 操作的结果是否成功的能力。</p>
<p>这与 <code class="docutils literal notranslate"><span class="pre">when_all()</span></code> 任何单个 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 操作的失败都会导致整体操作失败不同。这意味着您无法确定哪个组件 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 操作失败，并且还使您无法获取其他 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 操作的结果。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/when_all_ready.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="c1">// 同时 await 多个 Awaitable 对象.</span>
<span class="c1">//</span>
<span class="c1">// 返回一个 Awaitable 对象，当其被 co_await 时，</span>
<span class="c1">// 将会轮流等待所有输入的任务。当所有输入任务都完成后，</span>
<span class="c1">// 唤醒挂起的协程。</span>
<span class="c1">//</span>
<span class="c1">// co_await 返回的 Awaitable 对象，其结果是一个类型为</span>
<span class="c1">//  detail::when_all_task&lt;T&gt; 的 std::tuple。类型 T</span>
<span class="c1">// 是各个输入任务被 co_await 结果的类型。</span>
<span class="c1">//</span>
<span class="c1">// 输入的任务必须为 Awaitable 类型。当输入为右值时必须可移动，当输入为左值是必须可拷贝。 co_await 表达式将会运行在拷贝的右值上</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">AWAITABLES</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">when_all_ready</span><span class="p">(</span><span class="n">AWAITABLES</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">awaitables</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">when_all_task</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLES</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="o">&gt;</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// 并发等待输入任务队列中的任务</span>
<span class="k">template</span><span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="p">,</span>
   <span class="k">typename</span> <span class="n">RESULT</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">when_all_ready</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;</span> <span class="n">awaitables</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">when_all_task</span><span class="o">&lt;</span><span class="n">RESULT</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">get_record</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">);</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">example1</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 并发运行 3 个 get_record() 并等待它们完成</span>
<span class="c1">// 返回一个 std::tuple 类型，其可使用结构化绑定表达式进行解包。</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">,</span> <span class="n">task3</span><span class="p">]</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">when_all_ready</span><span class="p">(</span>
   <span class="n">get_record</span><span class="p">(</span><span class="mi">123</span><span class="p">),</span>
   <span class="n">get_record</span><span class="p">(</span><span class="mi">456</span><span class="p">),</span>
   <span class="n">get_record</span><span class="p">(</span><span class="mi">789</span><span class="p">));</span>

<span class="c1">// 对每个任务进行解包</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">record1</span> <span class="o">=</span> <span class="n">task1</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">record2</span> <span class="o">=</span> <span class="n">task2</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">record3</span> <span class="o">=</span> <span class="n">task3</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>

<span class="c1">// 使用 records....</span>
<span class="p">}</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">example2</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 创建输入的任务，但是还不开始执行</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">tasks</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">tasks</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">get_record</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// 同时运行所有的任务</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">when_all_task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">resultTasks</span> <span class="o">=</span>
   <span class="n">co_await</span> <span class="n">when_all_ready</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tasks</span><span class="p">));</span>

<span class="c1">// 一旦任务都完成，对其结果进行解包</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">try</span>
   <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">record</span> <span class="o">=</span> <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">result</span><span class="p">();</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">record</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id7">1</a></span></dt>
<dd><p>译者注：这里“返回的 Awaitable 对象”指的应当是 <code class="docutils literal notranslate"><span class="pre">when_all_ready()</span></code> 返回的 Awaitable 对象。</p>
</dd>
</dl>
</div>
<div class="section" id="fmap">
<h3><a class="toc-backref" href="#id53">fmap()</a><a class="headerlink" href="#fmap" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">fmap()</span></code> 用于将指定函数应用于容器内的元素，返回结果是一个新的、包含应用结果容器。</p>
<p><code class="docutils literal notranslate"><span class="pre">fmap()</span></code> 函数可以将一个函数应用于 <code class="docutils literal notranslate"><span class="pre">generator&lt;T&gt;</span></code> 、 <code class="docutils literal notranslate"><span class="pre">recursive_generator&lt;T&gt;</span></code> 和 `` async_generator&lt;T&gt;`` 的值以及任何支持 <code class="docutils literal notranslate"><span class="pre">Awaitable</span></code> 概念的值(例如: <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> )。</p>
<p>每一种类型都为 <code class="docutils literal notranslate"><span class="pre">fmap()</span></code> 提供了带两个参数的重载：要应用的函数和被应用的容器。有关支持的 <code class="docutils literal notranslate"><span class="pre">fmap()</span></code> 重载，请参见文档。</p>
<p>例如， <code class="docutils literal notranslate"><span class="pre">fmap()</span></code> 函数可用于将函数应用于 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 的结果，生成一个新的 <code class="docutils literal notranslate"><span class="pre">task&lt;U&gt;</span></code> ，该任务将使用函数的返回值来完成。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用一个函数来将类型 A 转换到类型 B</span>
<span class="n">B</span> <span class="nf">a_to_b</span><span class="p">(</span><span class="n">A</span> <span class="n">value</span><span class="p">);</span>

<span class="c1">// 一个生成类型为 A 的task</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">get_an_a</span><span class="p">();</span>

<span class="c1">// 我们可以使用 fmap() 函数将一个函数应用到 task 上，并获得新 task 的结果</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">bTask</span> <span class="o">=</span> <span class="n">fmap</span><span class="p">(</span><span class="n">a_to_b</span><span class="p">,</span> <span class="n">get_an_a</span><span class="p">());</span>

<span class="c1">// 另一种语法是使用管道表示法</span>
<span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">bTask</span> <span class="o">=</span> <span class="n">get_an_a</span><span class="p">()</span> <span class="o">|</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">fmap</span><span class="p">(</span><span class="n">a_to_b</span><span class="p">);</span>
</pre></div>
</div>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/fmap.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FUNC</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">fmap_transform</span>
<span class="p">{</span>
   <span class="n">fmap_transform</span><span class="p">(</span><span class="n">FUNC</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_move_constructible_v</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="o">&gt;</span><span class="p">);</span>
   <span class="n">FUNC</span> <span class="n">func</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 类型推导的构造函数，以便于使用 operator| 操作</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FUNC</span><span class="o">&gt;</span>
<span class="n">fmap_transform</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="o">&gt;</span> <span class="n">fmap</span><span class="p">(</span><span class="n">FUNC</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">);</span>

<span class="c1">// operator| 重载以便于为 fmap() 提供类似管道的语法糖</span>
<span class="c1">// 比如这种表达式：</span>
<span class="c1">//   &lt;value-expr&gt; | cppcoro::fmap(&lt;func-expr&gt;)</span>
<span class="c1">// 等价于：</span>
<span class="c1">//   fmap(&lt;func-expr&gt;, &lt;value-expr&gt;)</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">FUNC</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">fmap_transform</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="o">&gt;&amp;&amp;</span> <span class="n">transform</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">FUNC</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">fmap_transform</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="o">&gt;&amp;</span> <span class="n">transform</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">FUNC</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="k">const</span> <span class="n">fmap_transform</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="o">&gt;&amp;</span> <span class="n">transform</span><span class="p">);</span>

<span class="c1">// 所有 Awaitable 类型的通用重载</span>
<span class="c1">//</span>
<span class="c1">// 在被 co_await 时返回一个 Awaitable 对象。co_await 返回的对象并在其上应用指定的函数</span>
<span class="c1">// 类似于 &#39;std::invoke(func, co_await awaitable)&#39;</span>
<span class="c1">//</span>
<span class="c1">// 若 &#39;co_await awaitable&#39; 表达式的类型为 &#39;void&#39; 则 co_await</span>
<span class="c1">// 返回的 Awaitable 等价于 &#39;co_await awaitable, func()&#39;</span>
<span class="k">template</span><span class="o">&lt;</span>
   <span class="k">typename</span> <span class="n">FUNC</span><span class="p">,</span>
   <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="p">,</span>
   <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">is_awaitable_v</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">fmap</span><span class="p">(</span><span class="n">FUNC</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="n">AWAITABLE</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">FUNC</span><span class="p">,</span> <span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fmap()</span></code> 函数被设计成通过 <abbr title="Argument-Dependent Lookup, ADL">依赖于参数的查找</abbr> 来查找正确的重载，因此通常调用它时不应该使用 <code class="docutils literal notranslate"><span class="pre">cppcoro::</span></code> 前缀。</p>
</div>
<div class="section" id="schedule-on">
<h3><a class="toc-backref" href="#id54">schedule_on()</a><a class="headerlink" href="#schedule-on" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">schedule_on()</span></code> 函数可用于更改给定的 Awaitable 或开始执行的异步生成器的执行上下文</p>
<p>当应用到异步生成器时，它还会影响在 <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> 语句之后它将在哪个执行上下文上继续执行</p>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">schedule_on</span></code> 上的调度并不指定 Awaitable 或异步生成器完成或产生结果的线程，这取决于 Awaitable 或生成器的实现。</p>
<p>请参阅 <code class="docutils literal notranslate"><span class="pre">resume_on()</span></code> 如何控制任务在哪个线程上完成。</p>
<p>例子：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">get_value</span><span class="p">();</span>
<span class="n">io_service</span> <span class="n">ioSvc</span><span class="p">;</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 在当前线程上开始执行 get_value()</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">get_value</span><span class="p">();</span>

<span class="c1">// 在 ioSvc 的线程上执行 get_value()</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">schedule_on</span><span class="p">(</span><span class="n">ioSvc</span><span class="p">,</span> <span class="n">get_value</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/schedule_on.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="c1">// 返回一个 task ，其结果与 &#39;t&#39; 相同，但是确保 &#39;t&#39; 在被 co_await 时</span>
<span class="c1">// 在与调度器相关联的线程上执行。task 的结果将在 &#39;t&#39; 完成的线程上完成。</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="p">,</span> <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">schedule_on</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">AWAITABLE</span> <span class="n">awaitable</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_result_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 返回一个生成器，其序列与 &#39;source&#39; 相同，但是确保启动的协程在与调度器</span>
<span class="c1">// 相关联的线程上执行。在被 &#39;co_yield&#39; 后，在与调度器关联的线程上恢复</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">async_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">schedule_on</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">async_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">source</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">schedule_on_transform</span>
<span class="p">{</span>
   <span class="k">explicit</span> <span class="n">schedule_on_transform</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
<span class="n">schedule_on_transform</span><span class="o">&lt;</span><span class="n">SCHEDULER</span><span class="o">&gt;</span> <span class="n">schedule_on</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">schedule_on_transform</span><span class="o">&lt;</span><span class="n">SCHEDULER</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="resume-on">
<h3><a class="toc-backref" href="#id55">resume_on()</a><a class="headerlink" href="#resume-on" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">resume_on()</span></code> 函数可用于控制恢复挂起协程的执行上下文。当应用到异步生成器时，它控制 <code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">g.begin()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">++it</span></code> 操作在哪个执行上下文上恢复挂起的协程。</p>
<p>通常，等待 Awaitable 的协程(比如：一个 task )或异步生成器将在该操作完成的任何线程上恢复执行。在某些情况下，这可能不是您想要继续执行的线程。在这些情况下，您可以使用 <code class="docutils literal notranslate"><span class="pre">resume_on()</span></code> 函数创建一个新的 Awaitable 或生成器，它将在与指定调度程序关联的线程上恢复执行。</p>
<p><code class="docutils literal notranslate"><span class="pre">resume_on()</span></code> 函数可以用作返回新的 Awaitable/Generator 的普通函数也可以在管道语法中使用它。</p>
<p>例如：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">task</span><span class="o">&lt;</span><span class="n">record</span><span class="o">&gt;</span> <span class="n">load_record</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">);</span>

<span class="n">ui_thread_scheduler</span> <span class="n">uiThreadScheduler</span><span class="p">;</span>

<span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 这将在当前线程上启动 load_record()</span>
<span class="c1">// 然后当 load_record() 完成时（可能是一个 I/O 线程）</span>
<span class="c1">// 它将被重新调度到线程池并调用 to_json</span>
<span class="c1">// 一旦 to_json 完成，它将在被恢复前被调度到 ui 线程并返回 json 字符串</span>
<span class="n">task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">jsonTask</span> <span class="o">=</span>
   <span class="n">load_record</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
   <span class="o">|</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">resume_on</span><span class="p">(</span><span class="n">threadpool</span><span class="o">::</span><span class="k">default</span><span class="p">())</span>
   <span class="o">|</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">fmap</span><span class="p">(</span><span class="n">to_json</span><span class="p">)</span>
   <span class="o">|</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">resume_on</span><span class="p">(</span><span class="n">uiThreadScheduler</span><span class="p">);</span>

<span class="c1">// 此处，我们所做的就是创建一个 task 的流水线</span>
<span class="c1">// 任务不会立即开启</span>

<span class="c1">// Await 结果。开始 task 的流水线</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">jsonText</span> <span class="o">=</span> <span class="n">co_await</span> <span class="n">jsonTask</span><span class="p">;</span>

<span class="c1">// 保证在 ui 线程上执行</span>

<span class="n">someUiControl</span><span class="p">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">jsonText</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/resume_on.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="p">,</span> <span class="k">typename</span> <span class="n">AWAITABLE</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">resume_on</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">AWAITABLE</span> <span class="n">awaitable</span><span class="p">)</span>
   <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">awaitable_traits</span><span class="o">&lt;</span><span class="n">AWAITABLE</span><span class="o">&gt;::</span><span class="n">await_traits_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">async_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">resume_on</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">async_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">source</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">resume_on_transform</span>
<span class="p">{</span>
   <span class="k">explicit</span> <span class="n">resume_on_transform</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
   <span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 构建一个转发对象以便于能对源对象使用管道符（比如： operator| ）</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
<span class="n">resume_on_transform</span><span class="o">&lt;</span><span class="n">SCHEDULER</span><span class="o">&gt;</span> <span class="n">resume_on</span><span class="p">(</span><span class="n">SCHEDULER</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// 等价于 &#39;resume_on(transform.scheduler, std::forward&lt;T&gt;(value))&#39;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">SCHEDULER</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">resume_on_transform</span><span class="o">&lt;</span><span class="n">SCHEDULER</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">resume_on</span><span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id56">元函数</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<div class="section" id="awaitable-traits-t">
<h3><a class="toc-backref" href="#id57">awaitable_traits&lt;T&gt;</a><a class="headerlink" href="#awaitable-traits-t" title="Permalink to this headline">¶</a></h3>
<p>此元函数用于当 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 的类型为 T 时，其结果的类型。</p>
<p>注意：这里假设被 await 的类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的值在其上下文中没有被任何协程 Promise 对象的 <code class="docutils literal notranslate"><span class="pre">await_transform</span></code> 所影响。否则，类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的结果类型可能不同。</p>
<p>若类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 是不可 await 的，则 awaitable_traits&lt;T&gt; 原函数不会定义任何嵌套的 <code class="docutils literal notranslate"><span class="pre">awaiter_t</span></code> 或 <code class="docutils literal notranslate"><span class="pre">await_result_t</span></code> 类型。当类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 不可 await 时，这允许它在禁用重载的 <abbr title="Substitution Failure Is Not An Error">SFINAE</abbr> 上下文中被使用。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/awaitable_traits.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">awaitable_traits</span>
<span class="p">{</span>
   <span class="c1">// 若类型 T 支持 `operator co_await()` 则为 `operator co_await()` 类型 T 的结果，否则为 `T&amp;&amp;`</span>
   <span class="k">typename</span> <span class="n">awaiter_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">unspecified</span><span class="o">&gt;</span><span class="p">;</span>

   <span class="c1">// co_await 类型 T 的结果的值</span>
   <span class="k">typename</span> <span class="n">await_result_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">unspecified</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="is-awaitable-t">
<h3><a class="toc-backref" href="#id58">is_awaitable&lt;T&gt;</a><a class="headerlink" href="#is-awaitable-t" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">is_awaitable&lt;T&gt;</span></code> 元函数能用来查询协程中一个指定的类型能否被 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 。</p>
<p>API 摘要：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// &lt;cppcoro/is_awaitable.hpp&gt;</span>
<span class="k">namespace</span> <span class="n">cppcoro</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">is_awaitable</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">bool_constant</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_awaitable_v</span> <span class="o">=</span> <span class="n">is_awaitable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id59">概念</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<div class="section" id="awaitable-t">
<h3><a class="toc-backref" href="#id60">Awaitable&lt;T&gt;</a><a class="headerlink" href="#awaitable-t" title="Permalink to this headline">¶</a></h3>
<p><abbr title="Concepts">概念</abbr> <code class="docutils literal notranslate"><span class="pre">Awaitable&lt;T&gt;</span></code> 表明了一个在协程上下文中可被 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 的对象，并且没有 <code class="docutils literal notranslate"><span class="pre">await_transform</span></code> 的重载。其对应的 <code class="docutils literal notranslate"><span class="pre">co_await</span></code> 表达式类型为 <code class="docutils literal notranslate"><span class="pre">T</span></code> 。</p>
<p>比如， <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;</span></code> 实现了概念 <code class="docutils literal notranslate"><span class="pre">Awaitable&lt;T&amp;&amp;&gt;</span></code> ，而类型 <code class="docutils literal notranslate"><span class="pre">task&lt;T&gt;&amp;</span></code> 实现了概念 <code class="docutils literal notranslate"><span class="pre">Awaitable&lt;T&amp;&gt;</span></code></p>
</div>
<div class="section" id="awaiter-t">
<h3><a class="toc-backref" href="#id61">Awaiter&lt;T&gt;</a><a class="headerlink" href="#awaiter-t" title="Permalink to this headline">¶</a></h3>
<p>概念 <code class="docutils literal notranslate"><span class="pre">Awaiter&lt;T&gt;</span></code> 表明了一个类型，其实现了把被 await 的协程暂停/恢复的协议。其必须拥有的 <code class="docutils literal notranslate"><span class="pre">await_ready</span></code> 、 <code class="docutils literal notranslate"><span class="pre">await_suspend</span></code> 和 <code class="docutils literal notranslate"><span class="pre">await_resume</span></code> 方法。</p>
<p>假设有一个类型 <code class="docutils literal notranslate"><span class="pre">awaiter</span></code> ，则要满足 <code class="docutils literal notranslate"><span class="pre">Awaiter&lt;T&gt;</span></code> 的需求，其需要：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">awaiter.await_ready()</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">bool</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">awaiter.await_suspend(std::experimental::coroutine_handle&lt;void&gt;{})</span> <span class="pre">-&gt;</span> <span class="pre">void</span></code> 或 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 或 <code class="docutils literal notranslate"><span class="pre">std::experimental::coroutine_handle&lt;P&gt;</span></code> 对于一些 <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">awaiter.await_resume()</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code></p></li>
</ul>
<p>任何实现了概念 <code class="docutils literal notranslate"><span class="pre">Awaiter&lt;T&gt;</span></code> 的类型也同时实现了概念 <code class="docutils literal notranslate"><span class="pre">Awaitable&lt;T&gt;</span></code></p>
</div>
<div class="section" id="scheduler">
<h3><a class="toc-backref" href="#id62">Scheduler</a><a class="headerlink" href="#scheduler" title="Permalink to this headline">¶</a></h3>
<p>概念 <code class="docutils literal notranslate"><span class="pre">Scheduler</span></code> 改变了允许在一些执行上下文中调度协程的运行。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">concept</span> <span class="n">Scheduler</span>
<span class="p">{</span>
<span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">schedule</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>假设有类型 <code class="docutils literal notranslate"><span class="pre">S</span></code> 实现了 <code class="docutils literal notranslate"><span class="pre">Scheduler</span></code> 概念，且有实例 <code class="docutils literal notranslate"><span class="pre">s</span></code> 。则：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s.schedule()</span></code> 方法返回一个 Awaitable 类型。因此 <code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">s.schedule()</span></code> 将会无条件暂停当前协程并调度其在与 <code class="docutils literal notranslate"><span class="pre">s</span></code> 相关的协程内恢复。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">s.schedule()</span></code> 表达式的类型为 <code class="docutils literal notranslate"><span class="pre">void</span></code></p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cppcoro</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">Scheduler</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// 协程的执行最初在调用者的执行上下文中执行</span>

<span class="c1">// 暂停当前协程并调度其在 scheduler 的执行上下文中恢复</span>
<span class="n">co_await</span> <span class="n">scheduler</span><span class="p">.</span><span class="n">schedule</span><span class="p">();</span>

<span class="c1">// 现在协程运行在 scheduler 的执行上下文中</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="delayedscheduler">
<h3><a class="toc-backref" href="#id63">DelayedScheduler</a><a class="headerlink" href="#delayedscheduler" title="Permalink to this headline">¶</a></h3>
<p>概念 <code class="docutils literal notranslate"><span class="pre">DelayedScheduler</span></code> 允许协程自己调度自己在延迟一段时间后到调度器的执行上下文中。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">concept</span> <span class="nl">DelayedScheduler</span> <span class="p">:</span> <span class="n">Scheduler</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">REP</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RATIO</span><span class="o">&gt;</span>
<span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">schedule_after</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">REP</span><span class="p">,</span> <span class="n">RATIO</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">REP</span><span class="p">,</span> <span class="k">typename</span> <span class="n">RATIO</span><span class="o">&gt;</span>
<span class="n">Awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">schedule_after</span><span class="p">(</span>
   <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">REP</span><span class="p">,</span> <span class="n">RATIO</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">,</span>
   <span class="n">cppcoro</span><span class="o">::</span><span class="n">cancellation_token</span> <span class="n">cancellationToken</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>假设有类型 <code class="docutils literal notranslate"><span class="pre">S</span></code> 实现了 <code class="docutils literal notranslate"><span class="pre">DelayedScheduler</span></code> 概念，且有实例 <code class="docutils literal notranslate"><span class="pre">s</span></code> 。则：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s.schedule_after(delay)</span></code> 方法返回一个 Awaitable 类型。因此 <code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">s.schedule_after(delay)</span></code> 将会无条件暂停当前协程一段时间然后调度其在与 <code class="docutils literal notranslate"><span class="pre">s</span></code> 相关的协程内恢复。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">co_await</span> <span class="pre">s.schedule_after(delay)</span></code> 表达式的类型为 <code class="docutils literal notranslate"><span class="pre">void</span></code></p></li>
</ul>
</div>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id64">构建</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>cppcoro 库的 Windows 构建要求至少  Visual Studio 2017，而 Linux 构建至少要求 Clang 5.0</p>
<p>此库利用了 <a class="reference external" href="https://github.com/lewissbaker/cake">Cake 构建系统</a> （ 不是用于 <a class="reference external" href="http://cakebuild.net/">C#</a> 的这个）</p>
<p>Cake 构建系统会作为 git 子模块自动检出，所以你无需手动下载或安装它。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>译者注：</p>
<p>根据 vcpkg 中的 cppcoro 打包方式。 cppcoro 只需要仓库下的 <code class="docutils literal notranslate"><span class="pre">include/cppcoro</span></code> 文件夹，你可以将其拷贝到任意一个文件夹，然后在 CMake 或 其他构建工具中将其作为头文件目录包含即可。</p>
<p>由于PR <code class="docutils literal notranslate"><span class="pre">https://github.com/lewissbaker/cppcoro/pull/171</span></code> 还未被合并，在最新的编译器中你可能需要更改 cppcoro 中的代码以通过编译：将所有的 <code class="docutils literal notranslate"><span class="pre">std::experimental</span></code> 替换为 <code class="docutils literal notranslate"><span class="pre">std</span></code> ，将所有的 <code class="docutils literal notranslate"><span class="pre">experimental/</span></code> 删除。</p>
<p>参见 issue：<a class="reference external" href="https://github.com/lewissbaker/cppcoro/issues/191">https://github.com/lewissbaker/cppcoro/issues/191</a></p>
<p>和   PR   ：<a class="reference external" href="https://github.com/msys2/MINGW-packages/pull/7834">https://github.com/msys2/MINGW-packages/pull/7834</a></p>
</div>
<div class="section" id="windows">
<h3><a class="toc-backref" href="#id65">在 Windows 上构建</a><a class="headerlink" href="#windows" title="Permalink to this headline">¶</a></h3>
<p>这个库要求至少 Visual Studio 2017 ，还需要 Windows 10 SDK</p>
<p>对 Clang （ <a class="reference external" href="VisualStudio2017">#3</a> ）和 Linux 的支持正处于计划中。</p>
<div class="section" id="id13">
<h4><a class="toc-backref" href="#id66">Windows 环境需求</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>Cake 是由 Python 2.7 实现，因此要求安装 Python 2.7。</p>
<p>确保 Python2.7 解释器在你的 PATH 变量中，并且名为 python 。</p>
<p>确保 Visual Studio 2017 Update 3 已经安装。注意一些问题会出现在 Update 2 及以前的版本中，这些问题在 Update 3 才修复。</p>
<p>你也可以从 <a class="reference external" href="https://vcppdogfooding.azurewebsites.net/">https://vcppdogfooding.azurewebsites.net/</a> 下载并解压一个 NuGet 包以使用预览版本的 Visual Studio。解压  .nuget 到一个目录，并修改 <code class="docutils literal notranslate"><span class="pre">config.cake</span></code> 文件以指向此目录：</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="na">nugetPath</span> <span class="o">=</span> <span class="s">None # r&#39;C:\Path\To\VisualCppTools.14.0.25224-Pre&#39;</span>
</pre></div>
</div>
<p>确保 Windows 10 SDK 已经安装。默认情况下它会使用 Windows 10 SDK latest 和 Universal C Runtime。</p>
</div>
<div class="section" id="clone">
<h4><a class="toc-backref" href="#id67">Clone 仓库</a><a class="headerlink" href="#clone" title="Permalink to this headline">¶</a></h4>
<p>cppcoro 使用 git 子模块来拉取 Cake 构建系统的源码。</p>
<p>这意味着你在使用 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span></code> 时需要加上 <code class="docutils literal notranslate"><span class="pre">--recursive</span></code> 参数。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>c:\Code&gt; git clone --recursive https://github.com/lewissbaker/cppcoro.git
</pre></div>
</div>
<p>如果你已经克隆了 cppcoro，你需要更新子模块：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>c:\Code\cppcoro&gt; git submodule update --init --recursive
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4><a class="toc-backref" href="#id68">从命令行构构建</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>要从命令行构建只需要执行 'cake.bat' 文件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>C:\cppcoro&gt; cake.bat
Building with C:\cppcoro\config.cake - Variant(release=&#39;debug&#39;, platform=&#39;windows&#39;, architecture=&#39;x86&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Building with C:\cppcoro\config.cake - Variant(release=&#39;optimised&#39;, platform=&#39;windows&#39;, architecture=&#39;x64&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Building with C:\cppcoro\config.cake - Variant(release=&#39;debug&#39;, platform=&#39;windows&#39;, architecture=&#39;x64&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Building with C:\cppcoro\config.cake - Variant(release=&#39;optimised&#39;, platform=&#39;windows&#39;, architecture=&#39;x86&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Compiling test\main.cpp
Compiling test\main.cpp
Compiling test\main.cpp
Compiling test\main.cpp
...
Linking build\windows_x86_msvc14.10_debug\test\run.exe
Linking build\windows_x64_msvc14.10_optimised\test\run.exe
Linking build\windows_x86_msvc14.10_optimised\test\run.exe
Linking build\windows_x64_msvc14.10_debug\test\run.exe
Generating code
Finished generating code
Generating code
Finished generating code
Build succeeded.
Build took 0:00:02.419.
</pre></div>
</div>
<p>默认情况下，执行 <code class="docutils literal notranslate"><span class="pre">cake</span></code> 而不传入任何参数，将会构建项目的所有版本并进行单元测试。通过传入参数你可以缩减其构建的范围:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>c:\cppcoro&gt; cake.bat release=debug architecture=x64 lib/build.cake
Building with C:\Users\Lewis\Code\cppcoro\config.cake - Variant(release=&#39;debug&#39;, platform=&#39;windows&#39;, architecture=&#39;x64&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Archiving build\windows_x64_msvc14.10_debug\lib\cppcoro.lib
Build succeeded.
Build took 0:00:00.321.
</pre></div>
</div>
<p>你可以运行 <code class="docutils literal notranslate"><span class="pre">cake</span> <span class="pre">--help</span></code> 去列出所有可用的命令行选项。</p>
</div>
<div class="section" id="visual-studio">
<h4><a class="toc-backref" href="#id69">使用 Visual Studio 项目文件构建</a><a class="headerlink" href="#visual-studio" title="Permalink to this headline">¶</a></h4>
<p>如果希望在 Visual Studio 中构建，你可以运行 <code class="docutils literal notranslate"><span class="pre">cake.bat</span> <span class="pre">-p</span></code> 以生成 .vcproj/.sln 文件。</p>
<p>例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>c:\cppcoro&gt; cake.bat -p
Building with C:\cppcoro\config.cake - Variant(release=&#39;debug&#39;, platform=&#39;windows&#39;, architecture=&#39;x86&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Building with C:\cppcoro\config.cake - Variant(release=&#39;optimised&#39;, platform=&#39;windows&#39;, architecture=&#39;x64&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Building with C:\cppcoro\config.cake - Variant(release=&#39;debug&#39;, platform=&#39;windows&#39;, architecture=&#39;x64&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Building with C:\cppcoro\config.cake - Variant(release=&#39;optimised&#39;, platform=&#39;windows&#39;, architecture=&#39;x86&#39;, compilerFamily=&#39;msvc&#39;, compiler=&#39;msvc14.10&#39;)
Generating Solution build/project/cppcoro.sln
Generating Project build/project/cppcoro_tests.vcxproj
Generating Filters build/project/cppcoro_tests.vcxproj.filters
Generating Project build/project/cppcoro.vcxproj
Generating Filters build/project/cppcoro.vcxproj.filters
Build succeeded.
Build took 0:00:00.247.
</pre></div>
</div>
<p>当您从Visual Studio中构建这些项目时，它将调用 cake 来执行编译。</p>
</div>
</div>
<div class="section" id="linux">
<h3><a class="toc-backref" href="#id70">在 Linux 上构建</a><a class="headerlink" href="#linux" title="Permalink to this headline">¶</a></h3>
<p>cppcoro 也可以在拥有 Clang 和至少 libc++ 5.0 的 Linux 下构建。</p>
<p>构建 cppcoro 在 Ubuntu 17.04 上通过测试。</p>
<div class="section" id="id15">
<h4><a class="toc-backref" href="#id71">Linux 环境需求</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>确保以下包你已经安装：</p>
<ul class="simple">
<li><p>Python 2.7</p></li>
<li><p>Clang &gt;= 5.0</p></li>
<li><p>LLD &gt;= 5.0</p></li>
<li><p>libc++ &gt;= 5.0</p></li>
</ul>
</div>
<div class="section" id="cppcoro">
<h4><a class="toc-backref" href="#id72">构建 cppcoro</a><a class="headerlink" href="#cppcoro" title="Permalink to this headline">¶</a></h4>
<p>此处猜测 Clang 和 libc++ 你已经安装了。</p>
<p>如果您还没有配置 Clang ，请参阅以下部分，了解有关使用 Clang 构建 cppcoro 的配置细节。</p>
<p>检出 cppcoro 极其子模块：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>git clone --recursive https://github.com/lewissbaker/cppcoro.git cppcoro
</pre></div>
</div>
<p>运行 <code class="docutils literal notranslate"><span class="pre">init.sh</span></code> 以设置 <code class="docutils literal notranslate"><span class="pre">cake</span></code> 函数</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> cppcoro
<span class="nb">source</span> init.sh
</pre></div>
</div>
<p>然后，您可以从工作区根目录运行 cake 来构建 cppcoro 并运行测试：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cake
</pre></div>
</div>
<p>您可以指定额外的命令行参数来定制构建：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--help</span></code> 将打印出有关命令行参数的帮助</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--debug=run</span></code> 显示将要运行的构建命令行</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">release=debug</span></code> 或 <code class="docutils literal notranslate"><span class="pre">release=optimised</span></code> 会将构建变体限制为 debug 或 optimised （默认情况下，将同时构建两者）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lib/build.cake</span></code> 只会构建 cppcoro 库而没有单元测试。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">test/build.cake&#64;task_tests.cpp</span></code> 只会编译特定的源文件</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">test/build.cake&#64;testresult</span></code> 将构建并运行单元测试</p></li>
</ul>
<p>例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cake --debug=run release=debug lib/build.cake
</pre></div>
</div>
</div>
<div class="section" id="clang">
<h4><a class="toc-backref" href="#id73">自定义 Clang 位置</a><a class="headerlink" href="#clang" title="Permalink to this headline">¶</a></h4>
<p>如果你的 clang 编译器不是在 <code class="docutils literal notranslate"><span class="pre">/usr/bin/clang</span></code> ，则你可以 <code class="docutils literal notranslate"><span class="pre">cake</span></code> 的命令行选项来指出 clang 的位置：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--clang-executable=&lt;名称&gt;</span></code> 指定要使用的 clang 可执行文件名称，而不是clang。 例如：传入 <code class="docutils literal notranslate"><span class="pre">--clang-executable=clang-8</span></code> 以强制使用 Clang 8.0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--clang-executable=&lt;abspath&gt;</span></code> 指定 clang 可执行文件的完整路径。 构建系统还将在同一目录中查找其他可执行文件。 如果此路径的格式为 <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;/</span> <span class="pre">bin/&lt;name&gt;</span></code> ，则默认的 <code class="docutils literal notranslate"><span class="pre">clang-install-prefix</span></code> 将被设置为 <code class="docutils literal notranslate"><span class="pre">&lt;prefix&gt;</span></code> 。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--clang-install-prefix=&lt;路径&gt;</span></code> 指定安装 clang 的路径。这将导致构建系统在 <code class="docutils literal notranslate"><span class="pre">&lt;path&gt;/bin</span></code> 下查找 clang（除非被 <code class="docutils literal notranslate"><span class="pre">--clang-executable</span></code> 覆盖）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--libcxx-install-prefix=&lt;路径&gt;</span></code> 指定已安装的 libc++ 的路径。 默认情况下，构建系统将在与 clang 相同的位置寻找 libc++ 。 如果将其安装在其他位置，请使用此命令行选项。</p></li>
</ul>
<p>例如：使用安装在默认位置的特定版本的 clang</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cake --clang-executable=clang-8
</pre></div>
</div>
<p>例如：使用自定义位置下默认版本的 clang</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cake --clang-install-prefix=/path/to/clang-install
</pre></div>
</div>
<p>例如：使用自定义位置的 clang，自定义版本的 clang，自定义位置的 libc++ ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cake --clang-executable=/path/to/clang-install/bin/clang-8 --libcxx-install-prefix=/path/to/libcxx-install
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h4><a class="toc-backref" href="#id74">使用 Clang 的快照构建</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>如果您的 Linux 发行版没有 Clang 5.0 或更高版本，您可以从 LLVM 项目中安装一个快照构建。</p>
<p>按照 <a class="reference external" href="http://apt.llvm.org/">http://apt.llvm.org/</a> 上的说明设置软件包管理器，以支持从 LLVM 源中获取软件。</p>
<p>比如：对于 Ubuntu 17.04 Zesty：</p>
<p>编辑 <code class="docutils literal notranslate"><span class="pre">/etc/apt/sources.list</span></code> 并添加一下行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>deb http://apt.llvm.org/zesty/ llvm-toolchain-zesty main
deb-src http://apt.llvm.org/zesty/ llvm-toolchain-zesty main
</pre></div>
</div>
<p>安装 PGP 密钥：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -
</pre></div>
</div>
<p>安装 Clang 和 LLD ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo apt-get install clang-6.0 lld-6.0
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h4><a class="toc-backref" href="#id75">构建你的 Clang</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>你也可以使用最前沿的 Clang，自己从源代码构建 Clang 。</p>
<p>指令如下：</p>
<p>为此，您需要安装以下软件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo apt-get install git cmake ninja-build clang lld
</pre></div>
</div>
<p>请注意，我们正在使用您发行版的 clang 版本从源代码构建 clang 。这里也可以使用 GCC 。</p>
<p>检出 LLVM + Clang + LLD + libc++ 仓库：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mkdir llvm
<span class="nb">cd</span> llvm
git clone --depth<span class="o">=</span><span class="m">1</span> https://github.com/llvm-mirror/llvm.git llvm
git clone --depth<span class="o">=</span><span class="m">1</span> https://github.com/llvm-mirror/clang.git llvm/tools/clang
git clone --depth<span class="o">=</span><span class="m">1</span> https://github.com/llvm-mirror/lld.git llvm/tools/lld
git clone --depth<span class="o">=</span><span class="m">1</span> https://github.com/llvm-mirror/libcxx.git llvm/projects/libcxx
ln -s llvm/tools/clang clang
ln -s llvm/tools/lld lld
ln -s llvm/projects/libcxx libcxx
</pre></div>
</div>
<p>配置并构建 Clang :</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mkdir clang-build
<span class="nb">cd</span> clang-build
cmake -GNinja <span class="se">\</span>
      -DCMAKE_CXX_COMPILER<span class="o">=</span>/usr/bin/clang++ <span class="se">\</span>
      -DCMAKE_C_COMPILER<span class="o">=</span>/usr/bin/clang <span class="se">\</span>
      -DCMAKE_BUILD_TYPE<span class="o">=</span>MinSizeRel <span class="se">\</span>
      -DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="s2">&quot;/path/to/clang/install&quot;</span>
      -DCMAKE_BUILD_WITH_INSTALL_RPATH<span class="o">=</span><span class="s2">&quot;yes&quot;</span> <span class="se">\</span>
      -DLLVM_TARGETS_TO_BUILD<span class="o">=</span>X86 <span class="se">\</span>
      -DLLVM_ENABLE_PROJECTS<span class="o">=</span><span class="s2">&quot;lld;clang&quot;</span> <span class="se">\</span>
      ../llvm
ninja install-clang <span class="se">\</span>
      install-clang-headers <span class="se">\</span>
      install-llvm-ar <span class="se">\</span>
      install-lld
</pre></div>
</div>
</div>
<div class="section" id="libc">
<h4><a class="toc-backref" href="#id76">构建 libc++</a><a class="headerlink" href="#libc" title="Permalink to this headline">¶</a></h4>
<p>由于使用了 <code class="docutils literal notranslate"><span class="pre">&lt;experimental/coroutine&gt;</span></code> ，cppcoro 需要 libc++ 以使用 Clang 中的 C++ 协程。</p>
<p>检出 <code class="docutils literal notranslate"><span class="pre">libc++</span></code> + <code class="docutils literal notranslate"><span class="pre">llvm</span></code> ：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mkdir llvm
<span class="nb">cd</span> llvm
git clone --depth<span class="o">=</span><span class="m">1</span> https://github.com/llvm-mirror/llvm.git llvm
git clone --depth<span class="o">=</span><span class="m">1</span> https://github.com/llvm-mirror/libcxx.git llvm/projects/libcxx
ln -s llvm/projects/libcxx libcxx
</pre></div>
</div>
<p>构建 <code class="docutils literal notranslate"><span class="pre">libc++</span></code></p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>mkdir libcxx-build
<span class="nb">cd</span> libcxx-build
cmake -GNinja <span class="se">\</span>
      -DCMAKE_CXX_COMPILER<span class="o">=</span><span class="s2">&quot;/path/to/clang/install/bin/clang++&quot;</span> <span class="se">\</span>
      -DCMAKE_C_COMPILER<span class="o">=</span><span class="s2">&quot;/path/to/clang/install/bin/clang&quot;</span> <span class="se">\</span>
      -DCMAKE_BUILD_TYPE<span class="o">=</span>Release <span class="se">\</span>
      -DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="s2">&quot;/path/to/clang/install&quot;</span> <span class="se">\</span>
      -DLLVM_PATH<span class="o">=</span><span class="s2">&quot;../llvm&quot;</span> <span class="se">\</span>
      -DLIBCXX_CXX_ABI<span class="o">=</span>libstdc++ <span class="se">\</span>
      -DLIBCXX_CXX_ABI_INCLUDE_PATHS<span class="o">=</span><span class="s2">&quot;/usr/include/c++/6.3.0/;/usr/include/x86_64-linux-gnu/c++/6.3.0/&quot;</span> <span class="se">\</span>
      ../libcxx
ninja cxx
ninja install
</pre></div>
</div>
<p>这将构建并将 libc++ 安装到与 clang 相同的目录中。</p>
</div>
</div>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id77">支持</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>GitHub 的 issues 是支持、bug 报告和新特性请求的主要方式。</p>
<p>在同意 MIT 许可的情况下，欢迎任何贡献和 Pull-Requests 。</p>
<p>如果你遇到 C++ 协程的问题，一般你可以在 <a class="reference external" href="https://cpplang.slack.com/">Cpplang Slack</a> 组的 <code class="docutils literal notranslate"><span class="pre">#coroutines</span></code> 频道中获得帮助。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, cathaysia.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>